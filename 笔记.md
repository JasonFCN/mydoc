

#### 1，java多版本切换

```shell
sudo update-alternatives --config java
export JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64
export JRE_HOME=${JAVA_HOME}/jre  
export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib  
export PATH=${JAVA_HOME}/bin:$PATH
```

#### 2，创建快捷方式：

1）在/user/share/applications创建一个文件：xxx.desktop

```
cd /usr/share/applications
sudo gedit idea.desktop
```

2）文件中填写以下内容

```
[Desktop Entry]
Version=1.0
Type=Application
Name=Pycharm
Icon=/home/mengdan/Downloads/pycharm-2018.2.1/bin/pycharm.png
Exec=sh /home/mengdan/Downloads/pycharm-2018.2.1/bin/pycharm.sh
MimeType=application/x-py;
Name[en_US]=pycharm
```

3）通过快捷方式打开，然后锁定在桌面左侧。

#### 3，docker安装

```
# 安装
sudo apt install docker.io
# 启动
sudo systemctl start docker
# 开机启动
sudo systemctl enable docker

# 查看版本
docker -v

# 镜像搜索
docker search
# 镜像拉取
docker pull 镜像名:tag
# 镜像本地列表
docker images
# 删除镜像
docker rmi IMAGE_ID
# 运行一个容器
docker run --name container-name -d image-name
eg: docker run --name mytomcat -d tomcat     (--name:自定义名字 -d:后台运行)
# 查看运行中容器
docker ps        （-a: 查看所有）
# 停止容器
docker stop container-name/container-id
# 启动容器
docker start container-name/container-id
# 删除容器
docker rm comtainer-id
# 端口映射
-p 主机端口:容器端口
eg: docker run -d -p 6379:6379 --name myredis redis
#容器日志
docker logs container-name/container-id
```

部署ES

```shell
docker run -d --name es01 -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" elasticsearch
```

查看容器状态

```shell
docker stats
```

对ES配置环境参数（内存）

```shell
docker run -d --name es01 -p 9200:9200 -p 9300:9300 -e "discovery.tpye=single.node" -e ES_JAVA_OPTS="-Xzms64m -Xmx512m" elasticsearch
```

#### 4, openjdk卸载

要删除 OpenJDK (如果已安装的话)。首先，检查是安装的哪个 OpenJDK包。

```
# dpkg --list | grep -i jdk
```

移除 openjdk包:

```
# apt-get purge openjdk*
```

卸载 OpenJDK 相关包：

```
# apt-get purge icedtea-* openjdk-*
```

检查所有 OpenJDK包是否都已卸载完毕：

```
# dpkg --list | grep -i jdk
```

完毕。

#### 5，安装oraclejdk

下载文件：jdk-8u251-linux-x64.tar.gz

解压到目录/home/${user}/jdk

配置用户下的环境变量文件

```shell
sudo gedit ~/.bashrc
```

在文件末尾插入：

```shell
export JAVA_HOME=/home/jason/jdk/jdk-8u251-linux-x64/jdk1.8.0_251
export JRE_HOME=${JAVA_HOME}/jre  
export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib  
export PATH=${JAVA_HOME}/bin:$PATH
```

保存后让环境立即生效

```shell
source ~/.bashrc
```

验证

```shell
(base) jason@jason-X6Ti:~$ java -version
java version "1.8.0_251"
Java(TM) SE Runtime Environment (build 1.8.0_251-b08)
Java HotSpot(TM) 64-Bit Server VM (build 25.251-b08, mixed mode)
```

成功

#### 6,shell终端下的快捷键：

光标移动

```js
* ctrl + <      移动到前一个单词开头
* ctrl + >      移动到后一个单词结尾
* ctrl + A      移动到开头
* ctrl + E      移动到结尾
* alt  + B      向左移动一个单词
* alt  + F      向右移动一个单词
  ctrl + B      向左移动一个字符
  ctrl + F      向右移动一个字符
  esc  + B      向左移动一个单词
  esc  + F      向右移动一个单词
  ctrl + XX     在上次光和当前光标所在字符间跳转
  esc  + T      交换光标位置前的两个单词
```

删除

```js
* ctrl + K      删除光标后所有字符(剪切)
* ctrl + U      删除光标前所有字符(剪切)
* ctrl + W      删除光标前一个单词
  ctrl + D      删除光标所在字符(光标右侧)
  ctrl + H      删除光标前字符(光标左侧)
```

撤销

```js
* ctrl + _      撤销操作
* ctrl + Y      粘贴ctrl+U/K剪切的内容
  ctrl + ?      撤消前一次输入
  alt  + R      撤消前一次动作
```

替换

```js
* ctrl + T      将光标当前字符与前面一个字符替换
```

历史命令编辑

```js
* ctrl + P      上条输入的命令(相当于上键)
* ctrl + N      上条历史命(相当于下键)
* alt  + >      上一次执行命令
* ctrl + R      输入单词搜索历史命令
```

控制命令

```js
* ctrl + L      清除屏幕
  ctrl + S      锁住终端，阻止屏幕输出
  ctrl + Q      解锁终端，允许屏幕输出
  ctrl + C      终止命令&另起一行
  ctrl + I      补全功能(类似TAB)
  ctrl + O      重复执行命令
  alt  + <数字>  操作的次数
  ctrl + Z      挂起
```

!命令

```shell
* !!            执行上条命令
* !-n           执行前n条命令
```

#### 7，git 设置用户名密码永久保存

```shell
git config --global  credential.helper store
# 再输入一次账号密码就可以保存了
```

#### 8，anaconda 设置国内源

```shell
conda config --show 	# 查看当前配置

# 清华
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge 
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/

# 中科大
conda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/main/
conda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/free/
conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/conda-forge/
conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/msys2/
conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/bioconda/
conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/menpo/

conda config --set show_channel_urls yes	# 显示源信息

```

#### 9，文档处理

```java
package com.cwj.demo2;

import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.apache.pdfbox.pdmodel.PDDocument;
import org.apache.pdfbox.text.PDFTextStripper;
import org.apache.poi.POIXMLDocument;
import org.apache.poi.hwpf.HWPFDocument;
import org.apache.poi.hwpf.usermodel.Range;
import org.apache.poi.openxml4j.exceptions.OpenXML4JException;
import org.apache.poi.openxml4j.opc.OPCPackage;
import org.apache.poi.xwpf.extractor.XWPFWordExtractor;
import org.apache.xmlbeans.XmlException;

import java.io.*;
import java.text.SimpleDateFormat;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class TestWordread {
    public static void main(String[] args) throws IOException, OpenXML4JException, XmlException {
////        pdf2word();
//        String text = "";
//        text = readPDF();
////        System.out.println(text);
//        List<Result> results = results(text);
//        ObjectMapper mapper = new ObjectMapper();
//        mapper.setDateFormat(new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"));
//        mapper.disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);
//        String jsonStr = mapper.writeValueAsString(results);
//        System.out.println(jsonStr);
    }

    public static List<Result> results(String text) {
        List<Result> results = new ArrayList<>();
        String paragraph = "(?=知识点 |小试牛刀)([\\s\\S]+?)(?=小试牛刀|知识点 |第二部分 非选择题)";
        Pattern paragraphPattern = Pattern.compile(paragraph);
        String title = "(\\d+\\.[\\S\\s]+?（ ）[\\S\\s]+?)(?=A:)";
        Pattern titlePattern = Pattern.compile(title);
        String option = "([A-D]:\\S+?)\\s";
        Pattern optionPattern = Pattern.compile(option);
        String answer = "【答案】([A-D]+)\\s";
        Pattern answerPattern = Pattern.compile(answer);
        // 不能系统对换行的定义不同
        String reading = "【解析】[\\S \\n\\r]+?。\\r\\n";
        Pattern readingPattern = Pattern.compile(reading);
        String difficulty = "★+";
        Pattern difficultyPattern = Pattern.compile(difficulty);

        Matcher paragraphMatcher = paragraphPattern.matcher(text);
        while (paragraphMatcher.find()) {
            String s = paragraphMatcher.group(1);


            Matcher difficultyMatcher = difficultyPattern.matcher(s);
            int difficultyLevel = 0;
            if (difficultyMatcher.find()) {
                difficultyLevel = difficultyMatcher.group().length();
            }
            Matcher titleMatcher = titlePattern.matcher(s);
            Matcher optionMatcher = optionPattern.matcher(s);
            Matcher answerMatcher = answerPattern.matcher(s);
            Matcher readingMatcher = readingPattern.matcher(s);
            while (titleMatcher.find()) {
                Result result = new Result();

                // 题目
                String titleGroup = titleMatcher.group(1);
                if(titleGroup.contains("【单选题】")){
                    titleGroup.substring(titleGroup.indexOf("【单选题】")).replace("【单选题】", "");
                }
                result.setTitle(titleGroup);

                // 选项
                List<String> options = new ArrayList<>();
                for (int i = 0; i < 4; i++) {
                    if (optionMatcher.find()) {
                        String optionStr = optionMatcher.group(1).replaceAll("\r\n|\r|\n", "");
                        options.add(optionStr);
                    }
                }
                result.setOptions(options);

                // 答案
                if (answerMatcher.find()) {
                    String answerStr = answerMatcher.group(1);
                    result.setAnswer(answerStr);
                }

                // 解析
                if (readingMatcher.find()) {
                    String readingStr = readingMatcher.group();
                    result.setReading(readingStr);
                }

                // 难度
                result.setDifficulty(difficultyLevel);
                results.add(result);
            }
        }
        return results;
    }

    public static String readPDF() throws IOException {
        File file = new File("C:\\Users\\lenovo\\Desktop\\真题.pdf");
        PDDocument document = PDDocument.load(file);
        PDFTextStripper pdfTextStripper = new PDFTextStripper();
        String text = pdfTextStripper.getText(document);
        document.close();
        return text;
    }

    public static String readDocx() throws IOException, OpenXML4JException, XmlException {
        OPCPackage opcPackage = POIXMLDocument.openPackage("C:\\Users\\lenovo\\Desktop\\真题.docx");
        XWPFWordExtractor xwpfWordExtractor = new XWPFWordExtractor(opcPackage);
        String text = xwpfWordExtractor.getText();
        return text;
    }

    public static String readDoc() throws IOException, OpenXML4JException, XmlException {

        File file = new File("C:\\Users\\lenovo\\Desktop\\真题.doc");
        String str = "";
        try {
            FileInputStream fis = new FileInputStream(file);
            HWPFDocument doc = new HWPFDocument(fis);
            String doc1 = doc.getDocumentText();
            System.out.println(doc1);
            StringBuilder doc2 = doc.getText();
            System.out.println(doc2);

            Range rang = doc.getRange();
            String doc3 = rang.text();
            System.out.println(doc3);
            fis.close();
            return doc2.toString();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return str;
    }

    public static void pdf2word() {
        try {
            String pdfFile = "C:\\Users\\lenovo\\Desktop\\真题.pdf";
            PDDocument doc = PDDocument.load(new File(pdfFile));
            int pagenumber = doc.getNumberOfPages();
            pdfFile = pdfFile.substring(0, pdfFile.lastIndexOf("."));
            String fileName = pdfFile + ".doc";
            File file = new File(fileName);
            if (!file.exists()) {
                file.createNewFile();
            }
            FileOutputStream fos = new FileOutputStream(fileName);
            Writer writer = new OutputStreamWriter(fos, "UTF-8");
            PDFTextStripper stripper = new PDFTextStripper();
            stripper.setSortByPosition(true);// 排序
            stripper.setStartPage(1);// 设置转换的开始页
            stripper.setEndPage(pagenumber);// 设置转换的结束页
            stripper.writeText(doc, writer);
            writer.close();
            doc.close();
            System.out.println("pdf转换word成功！");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

class Result {
    private String title;
    private List<String> options;
    private String answer;
    private String reading;
    private Integer difficulty;

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public List<String> getOptions() {
        return options;
    }

    public void setOptions(List<String> options) {
        this.options = options;
    }

    public String getAnswer() {
        return answer;
    }

    public void setAnswer(String answer) {
        this.answer = answer;
    }

    public String getReading() {
        return reading;
    }

    public void setReading(String reading) {
        this.reading = reading;
    }

    public Integer getDifficulty() {
        return difficulty;
    }

    public void setDifficulty(Integer difficulty) {
        this.difficulty = difficulty;
    }

    @Override
    public String toString() {
        return "Result{" +
                "title='" + title + '\'' +
                ", options=" + options.toString() +
                ", answer='" + answer + '\'' +
                ", reading='" + reading + '\'' +
                ", difficulty=" + difficulty +
                '}';
    }
}
```

#### 10，SpringBoot 日期类型参数绑定，序列化

配置类型转换器：

```java
package com.cwj.config.cache;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.convert.converter.Converter;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

@Configuration
public class DateConverterConfig {
    @Bean
    public Converter<String, LocalDate> localDateConverter() {
        return new Converter<String, LocalDate>() {
            @Override
            public LocalDate convert(String source) {
                return LocalDate.parse(source, DateTimeFormatter.ofPattern("yyyy-MM-dd"));
            }
        };
    }

    @Bean
    public Converter<String, LocalDateTime> localDateTimeConverter() {
        return new Converter<String, LocalDateTime>() {
            @Override
            public LocalDateTime convert(String source) {
                return LocalDateTime.parse(source, DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"));
            }
        };
    }

//    @Bean
//    public Converter<String, Date> dateConverter() {
//        return new Converter<String, Date>() {
//            @SneakyThrows
//            @Override
//            public Date convert(String source) {
//                return new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").parse(source);
//            }
//        };
//    }
}
```

配置序列化器：

```java
package com.cwj.config.cache;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.databind.deser.std.DateDeserializers;
import com.fasterxml.jackson.databind.ser.std.DateSerializer;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import com.fasterxml.jackson.datatype.jsr310.deser.LocalDateTimeDeserializer;
import com.fasterxml.jackson.datatype.jsr310.ser.LocalDateTimeSerializer;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.autoconfigure.jackson.Jackson2ObjectMapperBuilderCustomizer;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.converter.json.Jackson2ObjectMapperBuilder;

import java.text.SimpleDateFormat;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Date;

@Configuration
public class LocalDateTimeSerializerConfig {

    @Value("${spring.jackson.date-format:yyyy-MM-dd HH:mm:ss}")
    private String pattern;

    @Bean
    public LocalDateTimeSerializer localDateTimeSerializer() {
        return new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(pattern));
    }

    @Bean
    public DateSerializer dateSerializer() {
        return new DateSerializer(true, new SimpleDateFormat(pattern));
    }

    @Bean
    public Jackson2ObjectMapperBuilderCustomizer jackson2ObjectMapperBuilderCustomizer() {
        return builder -> builder
                .serializerByType(LocalDateTime.class, localDateTimeSerializer())
//                .serializerByType(Date.class, dateSerializer())
                ;
    }

    @Bean
    public ObjectMapper serializingObjectMapper() {
        JavaTimeModule module = new JavaTimeModule();
        LocalDateTimeDeserializer dateTimeDeserializer = new LocalDateTimeDeserializer(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"));
//        MyLocalDateTimeDeserializer myLocalDateTimeDeserializer = new MyLocalDateTimeDeserializer(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"));
        DateDeserializers.DateDeserializer deserializer = new DateDeserializers.DateDeserializer(DateDeserializers.DateDeserializer.instance, new SimpleDateFormat(pattern), pattern);
        module.addDeserializer(LocalDateTime.class, dateTimeDeserializer);
        module.addSerializer(LocalDateTime.class, localDateTimeSerializer());
        module.addSerializer(Date.class, DateSerializer.instance.withFormat(false, new SimpleDateFormat(pattern)));
        module.addDeserializer(Date.class, deserializer);
        return Jackson2ObjectMapperBuilder.json().modules(module)
                .featuresToDisable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS).build();
    }

//    /** 默认日期时间格式 */
//    public static final String DEFAULT_DATE_TIME_FORMAT = "yyyy-MM-dd HH:mm:ss";
//    /** 默认日期格式 */
//    public static final String DEFAULT_DATE_FORMAT = "yyyy-MM-dd";
//    /** 默认时间格式 */
//    public static final String DEFAULT_TIME_FORMAT = "HH:mm:ss";
//
//    @Bean
//    public MappingJackson2HttpMessageConverter mappingJackson2HttpMessageConverter() {
//        MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter();
//        ObjectMapper objectMapper = new ObjectMapper();
//
//        // 忽略json字符串中不识别的属性
//        objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
//        // 忽略无法转换的对象
//        objectMapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false);
//        // PrettyPrinter 格式化输出
//        objectMapper.configure(SerializationFeature.INDENT_OUTPUT, true);
//        // NULL不参与序列化
//        objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);
//
//        // 指定时区
//        objectMapper.setTimeZone(TimeZone.getTimeZone("GMT+8:00"));
//        // 日期类型字符串处理
//        objectMapper.setDateFormat(new SimpleDateFormat(DEFAULT_DATE_TIME_FORMAT));
//
//        // java8日期日期处理
//        JavaTimeModule javaTimeModule = new JavaTimeModule();
//        javaTimeModule.addSerializer(LocalDateTime.class, new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)));
//        javaTimeModule.addSerializer(LocalDate.class, new LocalDateSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)));
//        javaTimeModule.addSerializer(LocalTime.class, new LocalTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)));
//        javaTimeModule.addDeserializer(LocalDateTime.class, new LocalDateTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)));
//        javaTimeModule.addDeserializer(LocalDate.class, new LocalDateDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)));
//        javaTimeModule.addDeserializer(LocalTime.class, new LocalTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)));
//        objectMapper.registerModule(javaTimeModule);
//
//        converter.setObjectMapper(objectMapper);
//        return converter;
//    }
}
```

#### 11，Redis配置序列化为json格式：

```java
package com.cwj.config.cache;

import com.fasterxml.jackson.annotation.JsonAutoDetect;
import com.fasterxml.jackson.annotation.PropertyAccessor;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.cache.RedisCacheConfiguration;
import org.springframework.data.redis.cache.RedisCacheManager;
import org.springframework.data.redis.cache.RedisCacheWriter;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;
import org.springframework.data.redis.serializer.RedisSerializationContext;
import org.springframework.data.redis.serializer.StringRedisSerializer;

import java.net.UnknownHostException;

@Configuration
public class RedisConfig {

    @Bean
    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory redisConnectionFactory) throws UnknownHostException {

        Jackson2JsonRedisSerializer<Object> serializer = new Jackson2JsonRedisSerializer<Object>(Object.class);
        ObjectMapper objectMapper = new ObjectMapper();
        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
        objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
        // 解决jackson2无法反序列化LocalDateTime的问题
        objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
        objectMapper.registerModule(new JavaTimeModule());
        
        serializer.setObjectMapper(objectMapper);

        RedisTemplate<String, Object> redisTemplate = new RedisTemplate<>();
        redisTemplate.setConnectionFactory(redisConnectionFactory);
        redisTemplate.setKeySerializer(new StringRedisSerializer());
        redisTemplate.setValueSerializer(serializer);
        redisTemplate.setHashKeySerializer(new StringRedisSerializer());
        redisTemplate.setHashValueSerializer(serializer);
        redisTemplate.afterPropertiesSet();

        return redisTemplate;
    }

    @Bean
    public RedisCacheManager redisCacheManager(RedisTemplate redisTemplate) {
        RedisCacheWriter redisCacheWriter = RedisCacheWriter.nonLockingRedisCacheWriter(redisTemplate.getConnectionFactory());
        RedisCacheConfiguration redisCacheConfiguration = RedisCacheConfiguration.defaultCacheConfig()
                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(redisTemplate.getValueSerializer()));
        return new RedisCacheManager(redisCacheWriter, redisCacheConfiguration);
    }
}
```

#### 12，SpringSecurity配置请求跨域：

```java
package com.cwj.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpMethod;
import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;

@Configuration
@EnableWebSecurity
@EnableGlobalMethodSecurity(prePostEnabled = true)
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {


    @Override
    protected void configure(HttpSecurity httpSecurity) throws Exception {
//        httpSecurity.cors().configurationSource(corsConfigurationSource());
        httpSecurity.cors().configurationSource(corsConfigurationSource()).and().csrf().disable()
//        httpSecurity.csrf().disable()
                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.NEVER)
                .and().authorizeRequests()
                .antMatchers("/**"
                ).permitAll()
                .antMatchers(HttpMethod.OPTIONS).permitAll()
                .anyRequest().authenticated().and().logout().permitAll();

    }

    @Bean
    CorsConfigurationSource corsConfigurationSource(){
        return httpServletRequest -> {
            CorsConfiguration cfg = new CorsConfiguration();
            cfg.addAllowedHeader("*");
            cfg.addAllowedMethod("*");
            cfg.addAllowedOrigin("*");
            cfg.setAllowCredentials(true);
            cfg.checkOrigin("*");
            return cfg;
        };
    }
}
```

或者：

```java
@Configuration
public class CorsConfig implements WebMvcConfigurer {

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/**")
                .allowedOrigins("*")
                .allowCredentials(true)
                .allowedMethods("GET", "POST", "DELETE", "PUT")
                .maxAge(3600);
    }
}
```



#### 13，数组元素交换的坑

```java
    public static void test01() {
        int[] arr = new int[]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
        System.out.println(Arrays.toString(arr));
        Random random = new Random();
        for (int i = 0; i < arr.length; i++) {
            int r = random.nextInt(arr.length);
            if(i != r){ // 该条件不能省略！因为两数交换是对应两个变量，当i == r时，对一个变量进行交换，结果该变量变成0
                arr[i] = arr[i] ^ arr[r];
            	arr[r] = arr[i] ^ arr[r];
            	arr[i] = arr[i] ^ arr[r];
            }
        }
        System.out.println();
        System.out.println(Arrays.toString(arr));
    }
```

#### 14，Mybatis Example语法

```java
// sql: where (条件1 and 条件2) or (条件3 and 条件4)

//条件1 and 条件2
example.createCriteria()
        .andEqualTo("isDeleted",IsDeleted.NOT_DELETED)
        .andEqualTo("name", projectCatalogEntity.getName());
//or (条件3 and 条件4)
example.or(example.createCriteria()
        .andEqualTo("isDeleted",IsDeleted.NOT_DELETED)
        .andEqualTo("code", projectCatalogEntity.getCode()));

where (条件1 and 条件2) and (条件3 or 条件4)

// sql: 条件1 and 条件2
example.createCriteria()
        .andEqualTo("isDeleted",IsDeleted.NOT_DELETED))
        .andEqualTo("parentId", projectCatalogEntity.getParentId());
//and (条件3 or 条件4)
example.and(example.createCriteria()
        .andEqualTo("name", projectCatalogEntity.getName())
        .orEqualTo("code", projectCatalogEntity.getCode()));

```

#### 15，枚举类的序列化与反序列化

序列化：在枚举类上添加注解：@JsonFormat(shape = JsonFormat.Shape.OBJECT)

反序列化：定义一个被注解：@JsonCreator 修饰的方法用于反序列化

```java
@Getter
@JsonFormat(shape = JsonFormat.Shape.OBJECT)
public enum DeleteEnum implements BasicEnum {
    //
    NOT_DELETE(1, "NOT_DELETE", "未删除"),
    DELETED(2, "DELETED", "已删除");

    private int code;
    private String logContent;
    private String description;

    DeleteEnum(final int code, final String logContent, final String description) {
        this.code = code;
        this.logContent = logContent;
        this.description = description;
    }

    /**
     * 用于保存所有的枚举值
     */
    private static Map<String, DeleteEnum> RESOURCE_MAP = Stream
            .of(DeleteEnum.values())
            .collect(Collectors.toMap(s -> s.getLogContent(), Function.identity()));


    /**
     * 枚举反序列话调用该方法
     *
     * @param jsonNode
     * @return
     */
    @JsonCreator //必须修饰static方法
    public static DeleteEnum des(final JsonNode jsonNode) {
        return Optional
                .ofNullable(RESOURCE_MAP.get(jsonNode.get("logContent").asText()))
                .orElseThrow(() -> new IllegalArgumentException(jsonNode.get("logContent").asText()));
    }

}
```

#### 16，logback-spring.xml配置

```xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration scan="true" scanPeriod="10 seconds">
    <!-- 日志级别从低到高分为TRACE < DEBUG < INFO < WARN < ERROR < FATAL，如果设置为WARN，则低于WARN的信息都不会输出 -->
    <!-- scan:当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true -->
    <!-- scanPeriod:设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当scan为true时，此属性生效。默认的时间间隔为1分钟。 -->
    <!-- debug:当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。 -->
    <contextName>logback</contextName>

    <property name="APP_NAME" value="myApp"/><!-- 项目名 -->
    <property name="LOG_HOME_DEV" value="c:/logs/${APP_NAME}"/><!-- 本地运行环境 -->
    <property name="LOG_HOME_TEST" value="c:/home/logs/${APP_NAME}"/><!--test环境 -->
    <property name="LOG_HOME_PROD" value="c:/logs/${APP_NAME}"/><!-- 生产环境 -->
    <springProfile name="dev">
        <property name="LOG_HOME" value="${LOG_HOME_DEV}"/><!-- 本地运行环境 -->
    </springProfile>
    <springProfile name="prod">
        <property name="LOG_HOME" value="${LOG_HOME_PROD}"/><!-- 本地运行环境 -->
    </springProfile>
    <springProfile name="test">
        <property name="LOG_HOME" value="${LOG_HOME_TEST}"/><!-- 本地运行环境 -->
    </springProfile>

    <!-- 彩色日志 -->
    <!-- 配置格式变量：CONSOLE_LOG_PATTERN 彩色日志格式 -->
    <!-- magenta:洋红 -->
    <!-- boldMagenta:粗红-->
    <!-- cyan:青色 -->
    <!-- white:白色 -->
    <!-- magenta:洋红 -->
    <property name="CONSOLE_LOG_PATTERN"
              value="%yellow(%date{yyyy-MM-dd HH:mm:ss}) |%highlight(%-5level) |%blue(%thread) |%blue(%file:%line) |%green(%logger) |%cyan(%msg%n)"/>


    <!--输出到控制台-->
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <Pattern>${CONSOLE_LOG_PATTERN}</Pattern>
            <!-- 设置字符集 -->
            <charset>UTF-8</charset>
        </encoder>
    </appender>


    <!--输出到文件-->
    <appender name="ALL_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <!-- 正在记录的日志文件的路径及文件名 -->
        <file>${LOG_HOME}/all.log</file>
        <!--日志文件输出格式-->
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n</pattern>
            <charset>UTF-8</charset>
        </encoder>
        <!-- 日志记录器的滚动策略，按日期，按大小记录 -->
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <!-- 每天日志归档路径以及格式 -->
            <fileNamePattern>${LOG_HOME}/%d{yyyy-MM-dd}/all-%d{yyyy-MM-dd}.%i.log</fileNamePattern>
            <timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP">
                <maxFileSize>100MB</maxFileSize>
            </timeBasedFileNamingAndTriggeringPolicy>
            <!--日志文件保留天数-->
            <maxHistory>15</maxHistory>
        </rollingPolicy>
    </appender>
    <!-- 时间滚动输出 level为 INFO 日志 -->
    <appender name="INFO_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <!-- 正在记录的日志文件的路径及文件名 -->
        <file>${LOG_HOME}/info.log</file>
        <!--日志文件输出格式-->
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n</pattern>
            <charset>UTF-8</charset>
        </encoder>
        <!-- 日志记录器的滚动策略，按日期，按大小记录 -->
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <!-- 每天日志归档路径以及格式 -->
            <fileNamePattern>${LOG_HOME}/%d{yyyy-MM-dd}/info-%d{yyyy-MM-dd}.%i.log</fileNamePattern>
            <timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP">
                <maxFileSize>100MB</maxFileSize>
            </timeBasedFileNamingAndTriggeringPolicy>
            <!--日志文件保留天数-->
            <maxHistory>15</maxHistory>
        </rollingPolicy>
        <!-- 此日志文件只记录info级别的 -->
        <filter class="ch.qos.logback.classic.filter.LevelFilter">
            <level>INFO</level>
            <onMatch>ACCEPT</onMatch>
            <onMismatch>DENY</onMismatch>
        </filter>
    </appender>

    <!-- 时间滚动输出 level为 WARN 日志 -->
    <appender name="WARN_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <!-- 正在记录的日志文件的路径及文件名 -->
        <file>${LOG_HOME}/warn.log</file>
        <!--日志文件输出格式-->
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n</pattern>
            <charset>UTF-8</charset> <!-- 此处设置字符集 -->
        </encoder>
        <!-- 日志记录器的滚动策略，按日期，按大小记录 -->
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>${LOG_HOME}/%d{yyyy-MM-dd}/warn-%d{yyyy-MM-dd}.%i.log</fileNamePattern>
            <timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP">
                <maxFileSize>100MB</maxFileSize>
            </timeBasedFileNamingAndTriggeringPolicy>
            <!--日志文件保留天数-->
            <maxHistory>15</maxHistory>
        </rollingPolicy>
        <!-- 此日志文件只记录warn级别的 -->
        <filter class="ch.qos.logback.classic.filter.LevelFilter">
            <level>WARN</level>
            <onMatch>ACCEPT</onMatch>
            <onMismatch>DENY</onMismatch>
        </filter>
    </appender>


    <!-- 时间滚动输出 level为 ERROR 日志 -->
    <appender name="ERROR_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <!-- 正在记录的日志文件的路径及文件名 -->
        <file>${LOG_HOME}/error.log</file>
        <!--日志文件输出格式-->
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n</pattern>
            <charset>UTF-8</charset> <!-- 此处设置字符集 -->
        </encoder>
        <!-- 日志记录器的滚动策略，按日期，按大小记录 -->
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>${LOG_HOME}/%d{yyyy-MM-dd}/error-%d{yyyy-MM-dd}.%i.log</fileNamePattern>
            <timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP">
                <maxFileSize>100MB</maxFileSize>
            </timeBasedFileNamingAndTriggeringPolicy>
            <!--日志文件保留天数-->
            <maxHistory>15</maxHistory>
        </rollingPolicy>
        <!-- 此日志文件只记录ERROR级别的 -->
        <filter class="ch.qos.logback.classic.filter.LevelFilter">
            <level>ERROR</level>
            <onMatch>ACCEPT</onMatch>
            <onMismatch>DENY</onMismatch>
        </filter>
    </appender>

    <!--
        <logger>用来设置某一个包或者具体的某一个类的日志打印级别、以及指定<appender>。
        <logger>仅有一个name属性，
        一个可选的level和一个可选的addtivity属性。
        name:用来指定受此logger约束的某一个包或者具体的某一个类。
        level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF，
              如果未设置此属性，那么当前logger将会继承上级的级别。
    -->
    <!--
        使用mybatis的时候，sql语句是debug下才会打印，而这里我们只配置了info，所以想要查看sql语句的话，有以下两种操作：
        第一种把<root level="INFO">改成<root level="DEBUG">这样就会打印sql，不过这样日志那边会出现很多其他消息
        第二种就是单独给mapper下目录配置DEBUG模式，代码如下，这样配置sql语句会打印，其他还是正常DEBUG级别：
     -->
    <!--可以输出项目中的debug日志，包括mybatis的sql日志-->
    <!--    <logger name="com.unicom.uac.mapper" level="DEBUG" addtivity="false" />-->
    <!--
        root节点是必选节点，用来指定最基础的日志输出级别，只有一个level属性
        level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF，默认是DEBUG
        可以包含零个或多个appender元素。
    -->
    <logger name="com.cwj.demo2.mapper" level="DEBUG" addtivity="false" />
    <springProfile name="dev | test">
        <property name="ROOT_LEVEL" value="INFO"/>
    </springProfile>
    <springProfile name="prod">
        <property name="ROOT_LEVEL" value="ERROR"/>
    </springProfile>
    <root level="${ROOT_LEVEL}">
        <appender-ref ref="CONSOLE" />
        <appender-ref ref="ALL_FILE" />
        <appender-ref ref="INFO_FILE" />
        <appender-ref ref="WARN_FILE" />
        <appender-ref ref="ERROR_FILE" />
    </root>

</configuration>
```

#### 17，ThreadLocal源码

ThreadLocal内存模型：

创建ThreadLocal对象后，调用set方法时，会先获取当前线程对象，判断当前线程对象中的属性（ThreadLocal.ThreadLocalMap）threadLocals是否为null，如果为空，则创建并设置初始值：key=当前

ThreadLocal对象，value=set(value);

![image-20201010144541013](%E7%AC%94%E8%AE%B0.assets/image-20201010144541013.png)

通过内存模型分析：当当前ThreadLocal对象使用完毕后，除了ThreadLocalMap中的Entity.key持有弱引用之外，没有别的对象再持有该对象的引用，则会在GC发生时对弱引用对象进行垃圾回收。此时，Enity.key = null，当前线程还在运行时，因为当前线程一直持有Entity的强引用。所以Entity不会被回收。这就造成内存泄漏风险。

即使Entity的key引用改成强引用，也是如此。内存泄漏发生的原因有两点：

1. Entity没有被remove;
2. 当前线程一直在运行；

防止内存泄漏的手段：

及时remove掉不再使用的entity;

问题1：ThreadLocal使用弱引用的是什么？

尽可能避免内存泄漏发生的机率；当弱引用被GC回收后，key=null,则在下一次调用ThreadLocal中的set/get/remvoe方法时，都会对key=null做判断，如果key=null,则value=null,即使当前线程依然在运行，key,value指向的对象已经被回收，避免内存泄漏。

问题2：ThreadLocal如果解决hash冲突的？

1. 通过魔法数字0x61c88647（斐波那契数列，黄金分割）生成key的hash，使其hash均匀的分布；
2. 通过hash & (len -1) 【len为2的幂】均匀的分布在数组下标上。
3. 通过线性探测法彻底避免hash冲突。

#### 18，文件二进制加密

java版：

```java
package com.cwj;

import java.io.*;

/**
 * @author chenwujie
 * @date 2020/10/1415:18
 */
public class FileEncrypt {
    private static int mask = 0b1011_0110;
    public static void main(String[] args) throws IOException {
        String srcPath = "C:\\VScodeProjects\\pythonPros\\fileEnpyro\\山水.jpg";
        String encryptPath = "C:\\VScodeProjects\\pythonPros\\fileEnpyro\\山水副本.jpg";
        String decryptPath = "C:\\VScodeProjects\\pythonPros\\fileEnpyro\\山水副本2.jpg";
//        encryptOrDecrypt(srcPath, encryptPath);
        encryptOrDecrypt(encryptPath, decryptPath);

    }

    /**
     * 文件加/解密
     * 对源文件数据用掩码进行异或运算（对源文件进行两次运算可以得到源文件相同信息）；
     * @param src   源文件路径
     * @param path_new 新文件路径
     * @throws IOException
     */
    public static void encryptOrDecrypt(String src, String path_new) throws IOException {
        File file = new File(src);
        File file2 = new File(path_new);
        FileInputStream inputStream = new FileInputStream(file);
        FileOutputStream outputStream = new FileOutputStream(file2);

        int data = 0;
        while((data = inputStream.read()) > -1){
            outputStream.write(data ^ mask);
        }

        inputStream.close();
        outputStream.flush();
        outputStream.close();
    }

    /**
     * 对字节数组加/解密
     * @param src 源文件字节数组
     * @return 返回新的数组
     */
    public static byte[] encryptOrDecrypt(byte[] src){
        if(src == null){
            return null;
        }
        byte[] data = new byte[src.length];
        for(int i = 0; i < src.length; i++){
            data[i] = (byte)(src[i] ^ mask);
        }
        return data;
    }
}
```

python版：

```python
def file_encrypt_or_decrypt(path, path2, mask=0x4b):
    """
    :param path: 源文件
    :param path2: 新文件
    :param mask: 掩码，用于对字节做异或运算
    :return:
    """
    file = open(path, mode='rb')
    file2 = open(path2, mode='wb')
    data = file.read()
    for index in range(len(data)):
        new_byte = data[index] ^ mask
        file2.write(bytes([new_byte]))


def file_bytes_encrypt_or_decrypt(data, mask=0x4b):
    """

    :param data: 元数据 bytes Type
    :param mask: 掩码，用于对字节做异或运算
    :return: 新的 bytes对象
    """
    length = len(data)
    arr = bytearray(length)
    for index in range(length):
        arr[index] = data[index] ^ mask
    return bytes(arr)


if __name__ == '__main__':
    pass
```

#### 19，字符串长度（human长度）

```java
package com.cwj;

/**
 * @author chenwujie
 * @date 2020/10/218:41
 */
public class StringTest {
    public static void main(String[] args) {
//        String s = "比如\uD83D\uDC69\u200D\uD83D\uDC69\u200D\uD83D\uDC67\u200D\uD83D\uDC66这个表情长";
        String s = "\uD83D\uDC69\u200D\uD83D\uDC69\u200D\uD83D\uDC67\u200D\uD83D\uDC66你好";
//        String s = "hello world!";
        System.out.println(s);
        System.out.println(s.length());
        System.out.println(humanStringLength(s));
    }

    public static int humanStringLength(String s){
        if(s == null){
            throw new NullPointerException();
        }
        int count = 0;
        int i = 0;
        while(i < s.length()){
            char c = s.charAt(i);
            if(Character.isHighSurrogate(c)){
                count++;
                i += 2;
            }else if(c > 0x2000 && c < 0x2010){
                if(i + 1 < s.length()){
                    char d = s.charAt(i+1);
                    if(Character.isHighSurrogate(d)){
                        i += 3;
                    }else{
                        i += 2;
                    }
                }
            }else{
                i++;
                count++;
            }
        }
        return count;
    }
}

```

#### 20，UTF-8字节流转字符串

```java
public int decode(byte[] var1, int var2, int var3, char[] var4) {
            int var5 = var2 + var3;
            int var6 = 0;
            int var7 = Math.min(var3, var4.length);

            ByteBuffer var8;
    		// 字节数组转字符数组
            for(var8 = null; var6 < var7 && var1[var2] >= 0; var4[var6++] = (char)var1[var2++]) {
            }

            while(true) {
                while(true) {
                    while(var2 < var5) {
                        byte var9 = var1[var2++];
                        if (var9 < 0) { // 不是单字节
                            byte var10;
                            // var9 != 0b110x_xxxx || var9 == 0b1100_000x
                            // 不是单字节也不是双字节 或者 ？
                            if (var9 >> 5 != -2 || (var9 & 30) == 0) {
                                byte var11;
                                
                                if (var9 >> 4 == -2) { // var9 == 0b1110_xxxx 说明是三字节表示一个字符
                                    if (var2 + 1 < var5) {
                                        var10 = var1[var2++];
                                        var11 = var1[var2++];
                                        if (isMalformed3(var9, var10, var11)) {
                                            if (this.malformedInputAction() != CodingErrorAction.REPLACE) {
                                                return -1;
                                            }

                                            var4[var6++] = this.replacement().charAt(0);
                                            var2 -= 3;
                                            var8 = getByteBuffer(var8, var1, var2);
                                            var2 += malformedN(var8, 3).length();
                                        } else {
                                            // 见：注释1
                                            char var15 = (char)(var9 << 12 ^ var10 << 6 ^ var11 ^ -123008);
                                            if (Character.isSurrogate(var15)) {
                                                if (this.malformedInputAction() != CodingErrorAction.REPLACE) {
                                                    return -1;
                                                }

                                                var4[var6++] = this.replacement().charAt(0);
                                            } else {
                                                var4[var6++] = var15;
                                            }
                                        }
                                    } else {
                                        if (this.malformedInputAction() != CodingErrorAction.REPLACE) {
                                            return -1;
                                        }

                                        if (var2 >= var5 || !isMalformed3_2(var9, var1[var2])) {
                                            var4[var6++] = this.replacement().charAt(0);
                                            return var6;
                                        }

                                        var4[var6++] = this.replacement().charAt(0);
                                    }
                                } else if (var9 >> 3 != -2) {// var9 != 0b1111_0xxx 既不是单字节、双字节、三字节，也不是四字节
                                    
                                    if (this.malformedInputAction() != CodingErrorAction.REPLACE) {
                                        return -1;
                                    }

                                    var4[var6++] = this.replacement().charAt(0);
                                } else if (var2 + 2 < var5) {// 只能是四字节
                                    var10 = var1[var2++];
                                    var11 = var1[var2++];
                                    byte var12 = var1[var2++];
                                    // 见：注释2
                                    int var13 = var9 << 18 ^ var10 << 12 ^ var11 << 6 ^ var12 ^ 3678080;
                                    if (!isMalformed4(var10, var11, var12) && Character.isSupplementaryCodePoint(var13)) {
                                        // 见：注释3
                                        var4[var6++] = Character.highSurrogate(var13);
                                        var4[var6++] = Character.lowSurrogate(var13);
                                    } else {
                                        if (this.malformedInputAction() != CodingErrorAction.REPLACE) {
                                            return -1;
                                        }

                                        var4[var6++] = this.replacement().charAt(0);
                                        var2 -= 4;
                                        var8 = getByteBuffer(var8, var1, var2);
                                        var2 += malformedN(var8, 4).length();
                                    }
                                } else {
                                    if (this.malformedInputAction() != CodingErrorAction.REPLACE) {
                                        return -1;
                                    }

                                    int var14 = var9 & 255;
                                    if (var14 <= 244 && (var2 >= var5 || !isMalformed4_2(var14, var1[var2] & 255))) {
                                        ++var2;
                                        if (var2 >= var5 || !isMalformed4_3(var1[var2])) {
                                            var4[var6++] = this.replacement().charAt(0);
                                            return var6;
                                        }

                                        var4[var6++] = this.replacement().charAt(0);
                                    } else {
                                        var4[var6++] = this.replacement().charAt(0);
                                    }
                                }
                            } else {
                                // 双字节
                                if (var2 >= var5) {
                                    if (this.malformedInputAction() != CodingErrorAction.REPLACE) {
                                        return -1;
                                    }

                                    var4[var6++] = this.replacement().charAt(0);
                                    return var6;
                                }

                                var10 = var1[var2++];
                                if (isNotContinuation(var10)) {
                                    if (this.malformedInputAction() != CodingErrorAction.REPLACE) {
                                        return -1;
                                    }

                                    var4[var6++] = this.replacement().charAt(0);
                                    --var2;
                                } else {
                                    // 见：注释4
                                    var4[var6++] = (char)(var9 << 6 ^ var10 ^ 3968);
                                }
                            }
                        } else {// 单字节
                            var4[var6++] = (char)var9;
                        }
                    }

                    return var6;
                }
            }
        }
```

注释1：

```txt
char var15 = (char)(var9 << 12 ^ var10 << 6 ^ var11 ^ -123008);
三字节：
1110xxxx10xxxxxx10xxxxxx

1111111111111110xxxx000000000000 字节1 << 12
11111111111111111110xxxxxx000000 字节2 << 6
11111111111111111111111110xxxxxx 字节3
11111111111111100001111110000000 掩码 -123008
-------------------------------- 异或
0000000000000000xxxxxxxxxxxxxxxx
```

注释2：

```txt
int var13 = var9 << 18 ^ var10 << 12 ^ var11 << 6 ^ var12 ^ 3678080;
四字节：
11110xxx 10xxxxxx 10xxxxxx 10xxxxxx

11111111110xxx000000000000000000 字节1 << 18
11111111111110xxxxxx000000000000 字节2 << 12
11111111111111111110xxxxxx000000 字节3 << 6
11111111111111111111111110xxxxxx 字节4
00000000001110000001111110000000 掩码 3678080
-------------------------------- 异或
00000000000xxxxxxxxxxxxxxxxxxxxx
```

注释3：

```java
/**
* 当unicode代码点超出基本平面BMP时，一个char不能表示该代码点。这就至少需要两个char来表示。但是为了能够区分一个字符表示的是BMP代码点，还是用两个字符表示的unicode代码点的其中一个，则在BMP特定区域不定义字符。专门留给utf16表示。该区域在: 
	D800-DB7F：高位替代字符 (High Surrogates)
	DB80-DBFF：高位专用替代字符 (High Private Use Surrogates)
	DC00-DFFF：低位替代字符 (Low Surrogates)
u >= 0x10000时, u` = u - 0x10000;已知u最大为0x10FFFF,所以u`最大 = 0x10FFFF - 0x10000 = 0xFFFFF，即0b1111_1111_1111_1111_1111;所以平分成两组：0bxxxx_xxxx_xxyy_yyyy_yyyy
分别映射到0b110110xxxxxxxxxx、0b110111yyyyyyyyyy,即范围：0xD800 ~ 0xDBFF、0xDC00 ~ 0xDFFF
所以
	高代理位：0b110110xxxxxxxxxx = 0xD800 + ((codePoint - 0x010000) >>> 10)
	低代理位：0b110111yyyyyyyyyy = 0xDC00 + (codePoint & 0x3FF) 0x3FF = 0b11_1111_1111
*

*/
public static char highSurrogate(int codePoint) {
    return (char) ((codePoint >>> 10)
    	+ (0xD800 - (0x010000 >>> 10)));
}
public static char lowSurrogate(int codePoint) {
    return (char) ((codePoint & 0x3ff) + 0xDC00);
}
```

注释4：

```txt
var4[var6++] = (char)(var9 << 6 ^ var10 ^ 3968);
双字节：
110xxxxx 10xxxxxx

111111111111111111110xxxxx000000 字节1 <<< 6
11111111111111111111111110xxxxxx 字节2
00000000000000000000111110000000 掩码 3968
-------------------------------- 异或
000000000000000000000xxxxxxxxxxx
```

#### 21，图片字节流转Base64

```java
import java.util.Base64;
/**
* 图片二进制流转base64
* @param bytes
* @return
*/
public String image2Base64(byte[] bytes){
    Base64.Encoder encoder = Base64.getEncoder();
    byte[] encode = encoder.encode(bytes);
    String base64Str = new String(encode);
    return "data:image/jpeg;base64," + base64Str;
}
```

#### 22，定时任务quartz简单使用

MyTask类：

```java
package com.cwj.timingTask;

import org.quartz.Job;
import org.quartz.JobExecutionContext;
import org.quartz.JobExecutionException;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

/**
 * @author chenwujie
 * @date 2020/11/049:20
 */
public class MyTask implements Job {
    @Override
    public void execute(JobExecutionContext jobExecutionContext) throws JobExecutionException {
        for (int i = 0; i < 5; i++) {
            System.out.println(jobExecutionContext);
            System.out.println("Thread-" + Thread.currentThread().getName() + "|time-" + LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")) + "|info-" + "test" + (i+1));
            try {
                Thread.sleep(1000 * 5);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

```

MyScheduler类

```java
package com.cwj.timingTask;

import org.quartz.*;
import org.quartz.impl.StdSchedulerFactory;

import java.util.Date;

/**
 * @author chenwujie
 * @date 2020/11/049:25
 */
public class MyScheduler {
    public static void main(String[] args) throws SchedulerException {
        StdSchedulerFactory stdSchedulerFactory = new StdSchedulerFactory();
        Scheduler scheduler = stdSchedulerFactory.getScheduler();

        JobDetail job1 = JobBuilder.newJob(MyTask.class).withDescription("job1").build();

        Date startDate = new Date();

        Date endDate = new Date();
        endDate.setTime(startDate.getTime() + 1000 * 60 * 5);
        CronTrigger cronTrigger = TriggerBuilder.newTrigger().withIdentity("trigger1", "triggerGroup1")
                .usingJobData("trigger1", "这是jobDetail1的trigger")
                .startAt(startDate)
                .endAt(endDate)
                .withSchedule(CronScheduleBuilder.cronSchedule("0/15 * * * * ?"))
                .build();

        scheduler.scheduleJob(job1, cronTrigger);
        System.out.println("任务开始---》");
        scheduler.start();
        System.out.println("任务结束----");

    }
}

```

console:

```txt
任务开始---》
任务结束----
Thread-DefaultQuartzScheduler_Worker-1|time-2020-11-04 10:09:00|info-test1
Thread-DefaultQuartzScheduler_Worker-1|time-2020-11-04 10:09:05|info-test2
Thread-DefaultQuartzScheduler_Worker-1|time-2020-11-04 10:09:10|info-test3
Thread-DefaultQuartzScheduler_Worker-2|time-2020-11-04 10:09:15|info-test1
Thread-DefaultQuartzScheduler_Worker-1|time-2020-11-04 10:09:15|info-test4
Thread-DefaultQuartzScheduler_Worker-2|time-2020-11-04 10:09:20|info-test2
Thread-DefaultQuartzScheduler_Worker-1|time-2020-11-04 10:09:20|info-test5
Thread-DefaultQuartzScheduler_Worker-2|time-2020-11-04 10:09:25|info-test3
Thread-DefaultQuartzScheduler_Worker-3|time-2020-11-04 10:09:30|info-test1
Thread-DefaultQuartzScheduler_Worker-2|time-2020-11-04 10:09:30|info-test4
Thread-DefaultQuartzScheduler_Worker-3|time-2020-11-04 10:09:35|info-test2
Thread-DefaultQuartzScheduler_Worker-2|time-2020-11-04 10:09:35|info-test5
Thread-DefaultQuartzScheduler_Worker-3|time-2020-11-04 10:09:40|info-test3
Thread-DefaultQuartzScheduler_Worker-4|time-2020-11-04 10:09:45|info-test1
Thread-DefaultQuartzScheduler_Worker-3|time-2020-11-04 10:09:45|info-test4
Thread-DefaultQuartzScheduler_Worker-4|time-2020-11-04 10:09:50|info-test2
Thread-DefaultQuartzScheduler_Worker-3|time-2020-11-04 10:09:50|info-test5
Thread-DefaultQuartzScheduler_Worker-4|time-2020-11-04 10:09:55|info-test3
Thread-DefaultQuartzScheduler_Worker-5|time-2020-11-04 10:10:00|info-test1
Thread-DefaultQuartzScheduler_Worker-4|time-2020-11-04 10:10:00|info-test4
Thread-DefaultQuartzScheduler_Worker-5|time-2020-11-04 10:10:05|info-test2
Thread-DefaultQuartzScheduler_Worker-4|time-2020-11-04 10:10:05|info-test5
Thread-DefaultQuartzScheduler_Worker-5|time-2020-11-04 10:10:10|info-test3
Thread-DefaultQuartzScheduler_Worker-6|time-2020-11-04 10:10:15|info-test1
Thread-DefaultQuartzScheduler_Worker-5|time-2020-11-04 10:10:15|info-test4
Thread-DefaultQuartzScheduler_Worker-6|time-2020-11-04 10:10:20|info-test2
Thread-DefaultQuartzScheduler_Worker-5|time-2020-11-04 10:10:20|info-test5
Thread-DefaultQuartzScheduler_Worker-6|time-2020-11-04 10:10:25|info-test3
Thread-DefaultQuartzScheduler_Worker-7|time-2020-11-04 10:10:30|info-test1
Thread-DefaultQuartzScheduler_Worker-6|time-2020-11-04 10:10:30|info-test4
Thread-DefaultQuartzScheduler_Worker-7|time-2020-11-04 10:10:35|info-test2
Thread-DefaultQuartzScheduler_Worker-6|time-2020-11-04 10:10:35|info-test5
Thread-DefaultQuartzScheduler_Worker-7|time-2020-11-04 10:10:40|info-test3
Thread-DefaultQuartzScheduler_Worker-8|time-2020-11-04 10:10:45|info-test1
Thread-DefaultQuartzScheduler_Worker-7|time-2020-11-04 10:10:45|info-test4
Thread-DefaultQuartzScheduler_Worker-8|time-2020-11-04 10:10:50|info-test2
Thread-DefaultQuartzScheduler_Worker-7|time-2020-11-04 10:10:50|info-test5
Thread-DefaultQuartzScheduler_Worker-8|time-2020-11-04 10:10:55|info-test3
Thread-DefaultQuartzScheduler_Worker-9|time-2020-11-04 10:11:00|info-test1
Thread-DefaultQuartzScheduler_Worker-8|time-2020-11-04 10:11:00|info-test4
Thread-DefaultQuartzScheduler_Worker-9|time-2020-11-04 10:11:05|info-test2
Thread-DefaultQuartzScheduler_Worker-8|time-2020-11-04 10:11:05|info-test5
Thread-DefaultQuartzScheduler_Worker-9|time-2020-11-04 10:11:10|info-test3

Process finished with exit code -1
```

每一次触发任务时，都会从线程池中分配一个线程用于执行当前任务。

#### 23，Integer.bitCount源码解析：

```java
// 求整数i的二进制1的个数
public static int bitCount(int i) {
    // HD, Figure 5-2
    i = i - ((i >>> 1) & 0x55555555);
    i = (i & 0x33333333) + ((i >>> 2) & 0x33333333);
    i = (i + (i >>> 4)) & 0x0f0f0f0f;
    i = i + (i >>> 8);
    i = i + (i >>> 16);
    return i & 0x3f;
}
```

先看两个bit位如何统计1的个数：

​	两位bit的情况：

| 二进制: b | 大小: m | 1的个数: n | 表达式：b - (b >>> 1) |
| --------- | ------- | ---------- | --------------------- |
| 00        | 0       | 0          | 0 - (0 >>> 1) = 0     |
| 01        | 1       | 1          | 1 - (1 >>> 1) = 1     |
| 10        | 2       | 1          | 2 - (2 >>> 1) = 1     |
| 11        | 3       | 2          | 3 - (3 >>> 1) = 2     |

结论：两位二进制数1的个数n = 二进制数本身 减去 高位的大小。

0x55555555 = 0b0101_0101_0101_0101_0101_0101_0101_0101

0x33333333 = 0b0011_0011_0011_0011_0011_0011_0011_0011

0x0F0F0F0F  = 0b0000_1111_0000_1111_0000_1111_0000_1111

0x0000003F =  0b0000_0000_0000_0000_0000_0000__0011_1111

步骤一：

```txt
i = i - ((i >>> 1) & 0x55555555);
i = 0bxyxy_xyxy_xyxy_xyxy_xyxy_xyxy_xyxy_xyxy;
i >>> 1 = 0b0xyx_yxyx_yxyx_yxyx_yxyx_yxyx_yxyx;
(i >>> 1) & 0x55555555 = 
	0b0xyx_yxyx_yxyx_yxyx_yxyx_yxyx_yxyx 		& 
	0b0101_0101_0101_0101_0101_0101_0101_0101
= 	0b0x0x_0x0x_0x0x_0x0x_0x0x_0x0x_0x0x_0x0x
i - ((i >>> 1) & 0x55555555) = 
0bxyxy_xyxy_xyxy_xyxy_xyxy_xyxy_xyxy_xyxy - 
0b0x0x_0x0x_0x0x_0x0x_0x0x_0x0x_0x0x_0x0x
因为 0bxy > 0b0x,所以每两位相减不存在向其他两位借位的情况。0bxy - 0b0y 正好符合表达式：b - (b >>> 1)
```

步骤二：

```
i = (i & 0x33333333) + ((i >>> 2) & 0x33333333);

i & 0x33333333 = 
0bxxyy_xxyy_xxyy_xxyy_xxyy_xxyy_xxyy_xxyy &
0b0011_0011_0011_0011_0011_0011_0011_0011 = 
0b00yy_00yy_00yy_00yy_00yy_00yy_00yy_00yy

(i >>> 2) & 0x33333333 = 
(0bxxyy_xxyy_xxyy_xxyy_xxyy_xxyy_xxyy_xxyy >>> 2) &
0b0011_0011_0011_0011_0011_0011_0011_0011 = 
0b00xx_00xx_00xx_00xx_00xx_00xx_00xx_00xx &
0b0011_0011_0011_0011_0011_0011_0011_0011 = 
0b00xx_00xx_00xx_00xx_00xx_00xx_00xx_00xx

(i & 0x33333333) + ((i >>> 2) & 0x33333333) = 
0b00yy_00yy_00yy_00yy_00yy_00yy_00yy_00yy +
0b00xx_00xx_00xx_00xx_00xx_00xx_00xx_00xx = 
0b00zz_00zz_00zz_00zz_00zz_00zz_00zz_00zz
```

步骤三：

```txt
i = (i + (i >>> 4)) & 0x0f0f0f0f; 
其实：(i + (i >>> 4)) & 0x0f0f0f0f 等同于 (i & 0x0f0f0f0f) + ((i >>> 4) & 0x0f0f0f0f)。
(i & 0x0f0f0f0f) + ((i >>> 4) & 0x0f0f0f0f) 不再赘述，来看看：(i + (i >>> 4)) & 0x0f0f0f0f

i >>> 4 = 
0b00zz_00zz_00zz_00zz_00zz_00zz_00zz_00zz >>> 4 = 
0b0000_00zz_00zz_00zz_00zz_00zz_00zz_00zz
(i + (i >>> 4)) & 0x0f0f0f0f = 
(0b00zz_00zz_00zz_00zz_00zz_00zz_00zz_00zz + 
 0b0000_00zz_00zz_00zz_00zz_00zz_00zz_00zz) &
 0b0000_1111_0000_1111_0000_1111_0000_1111 = 
 ob0000_zzzz_0000_zzzz_0000_zzzz_0000_zzzz
高四位通过>>>4 与低四位对齐，只对低四位之和 & 1111 = 两组4位数值之和
```

步骤四：

```
i = i + (i >>> 8);

i + (i >>> 8) = 
ob0000_1111_0000_2222_0000_3333_0000_4444 + (ob0000_1111_0000_2222_0000_3333_0000_4444 >>> 8) = 
ob0000_1111_0000_2222_0000_3333_0000_4444 + 
ob0000_0000_0000_1111_0000_2222_0000_3333
ob0000_xxxx_000x_xxxx_000y_yyyy_000y_yyyy
```

步骤五：

```
i = i + (i >>> 16);
i + (i >>> 16) = 
ob0000_xxxx_000x_xxxx_000y_yyyy_000y_yyyy +
(ob0000_xxxx_000x_xxxx_000y_yyyy_000y_yyyy >>> 16) = 
ob0000_xxxx_000x_xxxx_000y_yyyy_000y_yyyy +
ob0000_0000_0000_0000_0000_xxxx_000x_xxxx = 
0b0000_xxxx_000x_xxxx_000x_xxxx_00zz_zzzz
```

步骤六：

```txt
i & 0x3f;
0b0000_xxxx_000x_xxxx_000x_xxxx_00zz_zzzz &
0b0000_0000_0000_0000_0000_0000_0011_1111 = 
0b0000_0000_0000_0000_0000_0000_00zz_zzzz

```

总结：

​	思路：

		1. 每两个bit位为一组，转换成该组1的个数表示。
  		2. 用更大的分组来统计1的个数。
                		3. 最终总的个数都汇总到低6位上。
            		4. 对结果数截取低6位，该数就是1的个数。

#### 24，字符串转字节

```java
        public int encode(char[] var1, int var2, int var3, byte[] var4) {
            int var5 = var2 + var3;
            int var6 = 0;

            for(int var7 = var6 + Math.min(var3, var4.length); var6 < var7 && var1[var2] < 128; var4[var6++] = (byte)var1[var2++]) {
            }

            while(var2 < var5) {
                char var8 = var1[var2++];
                if (var8 < 128) {
                    var4[var6++] = (byte)var8;
                } else if (var8 < 2048) {
                    var4[var6++] = (byte)(192 | var8 >> 6);
                    var4[var6++] = (byte)(128 | var8 & 63);
                } else if (Character.isSurrogate(var8)) {
                    if (this.sgp == null) {
                        this.sgp = new Parser();
                    }

                    int var9 = this.sgp.parse(var8, var1, var2 - 1, var5);
                    if (var9 < 0) {
                        if (this.malformedInputAction() != CodingErrorAction.REPLACE) {
                            return -1;
                        }

                        var4[var6++] = this.repl;
                    } else {
                        var4[var6++] = (byte)(240 | var9 >> 18);
                        var4[var6++] = (byte)(128 | var9 >> 12 & 63);
                        var4[var6++] = (byte)(128 | var9 >> 6 & 63);
                        var4[var6++] = (byte)(128 | var9 & 63);
                        ++var2;
                    }
                } else {
                    var4[var6++] = (byte)(224 | var8 >> 12);
                    var4[var6++] = (byte)(128 | var8 >> 6 & 63);
                    var4[var6++] = (byte)(128 | var8 & 63);
                }
            }

            return var6;
        }
```

#### 25, 压缩文件读取异常：Exception in thread "main" java.lang.IllegalArgumentException: MALFORMED

```java
package com.cwj;

import java.io.FileInputStream;
import java.io.IOException;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;
import java.util.zip.ZipInputStream;

/**
 * @author chenwujie
 * @date 2020/11/0211:10
 */
public class ZipTest {
    public static void main(String[] args) throws IOException {
        long t1 = System.currentTimeMillis();
        ZipInputStream zipInputStream = new ZipInputStream( new FileInputStream("D:\\160548948330.zip"));
        ZipEntry zip = null;
        while ((zip = zipInputStream.getNextEntry()) != null){
            if(zip.isDirectory()){
                continue;
            }
            System.out.println(zip.getName());
        }
        long t2 = System.currentTimeMillis();

        System.out.println(t2 -t1);
    }
}

```

异常：

```shell
Exception in thread "main" java.lang.IllegalArgumentException: MALFORMED
	at java.util.zip.ZipCoder.toString(ZipCoder.java:58)
	at java.util.zip.ZipInputStream.readLOC(ZipInputStream.java:300)
	at java.util.zip.ZipInputStream.getNextEntry(ZipInputStream.java:122)
	at com.cwj.ZipTest.main(ZipTest.java:20)
```

原因：读取压缩文件中的Entry文件名时，编码错误（默认用UTF-8）。而我们的zip文件压缩时的格式可能是GBK

解决办法：

1. 指定正确的编码

2. 指定ISO-8859-1编码

   该编码解码时，不会异常，但得到的文件名是不正确的（如果含有非ASCII码）。如果想得到正确的文件名，需要知道正确的编码格式，重新对文件名解码即可。

```java
package com.cwj;

import java.io.FileInputStream;
import java.io.IOException;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;
import java.util.zip.ZipInputStream;

/**
 * @author chenwujie
 * @date 2020/11/0211:10
 */
public class ZipTest {
    public static void main(String[] args) throws IOException {
        long t1 = System.currentTimeMillis();
        ZipInputStream zipInputStream = new ZipInputStream( new FileInputStream("D:\\task\\1605489483300_task.zip"), StandardCharsets.ISO_8859_1);
        ZipEntry zip = null;
        while ((zip = zipInputStream.getNextEntry()) != null){
            if(zip.isDirectory()){
                continue;
            }
            System.out.println(zip.getName());
            System.out.println(new String(zip.getName().getBytes(StandardCharsets.ISO_8859_1), Charset.forName("GBK")));
        }
        long t2 = System.currentTimeMillis();

        System.out.println(t2 -t1);
    }
}

```

```shell
1595224842083_test.cgr
1595224842083_test.cgr
1597214878842_È¨ÏÞ¶ÔÓ¦±í.xlsx
1597214878842_权限对应表.xlsx
1599026278114_link001.stp
1599026278114_link001.stp
2
```

#### 26, GET请求接收数组参数

请求：http://localhost:8080/api/test?ids=1,2,3或者http://localhost:8080/api/test?ids=1&ids=2&ids=3

```java
    public void test(@RequestParam List<Integer> ids) throws Exception {

    }
	// 或者
	public void test(@RequestParam Integer[] ids) throws Exception {

    }
```

#### 27，文件下载鉴权

服务端代码：

```java
@GetMapping("fd")
    public void fd(HttpServletResponse response, String i, String s) throws Exception {
        if(iSet.contains(i) && sSet.contains(s)){
            response.setHeader("X-Accel-Redirect", "/down/b9d2af3dc1374ecc746c25641ca6c0db.jpg");
            response.setHeader("Content-Type", "application/octet-stream;charset=utf-8");
            response.setHeader("Content-Disposition", "attachment;filename=a.jpg");
        }else{
            response.setHeader("Content-Type", "application/json; charset=utf-8");
            response.getWriter().write("{\"code\": 504, \"message\": \"文件不存在\"}");
            response.getWriter().close();
        }
    }
```

ngix配置：

```txt
server {
        listen       8185;   #监听端口
        server_name  demo2;   #监听地址       
		
		location  / {
           proxy_pass  http://localhost:8085/;         
        } 
		location  /down {
		    internal;
			root down;  
        }		
    }
```

文件真实路径：D:\nginx-1.19.2\down\b9d2af3dc1374ecc746c25641ca6c0db.jpg

