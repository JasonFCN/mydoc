#### 1，java多版本切换

```shell
sudo update-alternatives --config java
export JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64
export JRE_HOME=${JAVA_HOME}/jre  
export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib  
export PATH=${JAVA_HOME}/bin:$PATH
```

#### 2，创建快捷方式：

1）在/user/share/applications创建一个文件：xxx.desktop

```
cd /usr/share/applications
sudo gedit idea.desktop
```

2）文件中填写以下内容

```
[Desktop Entry]
Version=1.0
Type=Application
Name=Pycharm
Icon=/home/mengdan/Downloads/pycharm-2018.2.1/bin/pycharm.png
Exec=sh /home/mengdan/Downloads/pycharm-2018.2.1/bin/pycharm.sh
MimeType=application/x-py;
Name[en_US]=pycharm
```

3）通过快捷方式打开，然后锁定在桌面左侧。

#### 3，docker安装

```
# 安装
sudo apt install docker.io
# 启动
sudo systemctl start docker
# 开机启动
sudo systemctl enable docker

# 查看版本
docker -v

# 镜像搜索
docker search
# 镜像拉取
docker pull 镜像名:tag
# 镜像本地列表
docker images
# 删除镜像
docker rmi IMAGE_ID
# 运行一个容器
docker run --name container-name -d image-name
eg: docker run --name mytomcat -d tomcat     (--name:自定义名字 -d:后台运行)
# 查看运行中容器
docker ps        （-a: 查看所有）
# 停止容器
docker stop container-name/container-id
# 启动容器
docker start container-name/container-id
# 删除容器
docker rm comtainer-id
# 端口映射
-p 主机端口:容器端口
eg: docker run -d -p 6379:6379 --name myredis redis
#容器日志
docker logs container-name/container-id
```

部署ES

```shell
docker run -d --name es01 -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" elasticsearch
```

查看容器状态

```shell
docker stats
```

对ES配置环境参数（内存）

```shell
docker run -d --name es01 -p 9200:9200 -p 9300:9300 -e "discovery.tpye=single.node" -e ES_JAVA_OPTS="-Xzms64m -Xmx512m" elasticsearch
```

#### 4, openjdk卸载

要删除 OpenJDK (如果已安装的话)。首先，检查是安装的哪个 OpenJDK包。

```
# dpkg --list | grep -i jdk
```

移除 openjdk包:

```
# apt-get purge openjdk*
```

卸载 OpenJDK 相关包：

```
# apt-get purge icedtea-* openjdk-*
```

检查所有 OpenJDK包是否都已卸载完毕：

```
# dpkg --list | grep -i jdk
```

完毕。

#### 5，安装oraclejdk

下载文件：jdk-8u251-linux-x64.tar.gz

解压到目录/home/${user}/jdk

配置用户下的环境变量文件

```shell
sudo gedit ~/.bashrc
```

在文件末尾插入：

```shell
export JAVA_HOME=/home/jason/jdk/jdk-8u251-linux-x64/jdk1.8.0_251
export JRE_HOME=${JAVA_HOME}/jre  
export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib  
export PATH=${JAVA_HOME}/bin:$PATH
```

保存后让环境立即生效

```shell
source ~/.bashrc
```

验证

```shell
(base) jason@jason-X6Ti:~$ java -version
java version "1.8.0_251"
Java(TM) SE Runtime Environment (build 1.8.0_251-b08)
Java HotSpot(TM) 64-Bit Server VM (build 25.251-b08, mixed mode)
```

成功

#### 6,shell终端下的快捷键：

光标移动

```js
* ctrl + <      移动到前一个单词开头
* ctrl + >      移动到后一个单词结尾
* ctrl + A      移动到开头
* ctrl + E      移动到结尾
* alt  + B      向左移动一个单词
* alt  + F      向右移动一个单词
  ctrl + B      向左移动一个字符
  ctrl + F      向右移动一个字符
  esc  + B      向左移动一个单词
  esc  + F      向右移动一个单词
  ctrl + XX     在上次光和当前光标所在字符间跳转
  esc  + T      交换光标位置前的两个单词
```

删除

```js
* ctrl + K      删除光标后所有字符(剪切)
* ctrl + U      删除光标前所有字符(剪切)
* ctrl + W      删除光标前一个单词
  ctrl + D      删除光标所在字符(光标右侧)
  ctrl + H      删除光标前字符(光标左侧)
```

撤销

```js
* ctrl + _      撤销操作
* ctrl + Y      粘贴ctrl+U/K剪切的内容
  ctrl + ?      撤消前一次输入
  alt  + R      撤消前一次动作
```

替换

```js
* ctrl + T      将光标当前字符与前面一个字符替换
```

历史命令编辑

```js
* ctrl + P      上条输入的命令(相当于上键)
* ctrl + N      上条历史命(相当于下键)
* alt  + >      上一次执行命令
* ctrl + R      输入单词搜索历史命令
```

控制命令

```js
* ctrl + L      清除屏幕
  ctrl + S      锁住终端，阻止屏幕输出
  ctrl + Q      解锁终端，允许屏幕输出
  ctrl + C      终止命令&另起一行
  ctrl + I      补全功能(类似TAB)
  ctrl + O      重复执行命令
  alt  + <数字>  操作的次数
  ctrl + Z      挂起
```

!命令

```shell
* !!            执行上条命令
* !-n           执行前n条命令
```

#### 7，git 设置用户名密码永久保存

```shell
git config --global  credential.helper store
# 再输入一次账号密码就可以保存了
```

#### 8，anaconda 设置国内源

```shell
conda config --show 	# 查看当前配置

# 清华
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge 
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/

# 中科大
conda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/main/
conda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/free/
conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/conda-forge/
conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/msys2/
conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/bioconda/
conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/menpo/

conda config --set show_channel_urls yes	# 显示源信息

```

#### 9，文档处理

```java
package com.cwj.demo2;

import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.apache.pdfbox.pdmodel.PDDocument;
import org.apache.pdfbox.text.PDFTextStripper;
import org.apache.poi.POIXMLDocument;
import org.apache.poi.hwpf.HWPFDocument;
import org.apache.poi.hwpf.usermodel.Range;
import org.apache.poi.openxml4j.exceptions.OpenXML4JException;
import org.apache.poi.openxml4j.opc.OPCPackage;
import org.apache.poi.xwpf.extractor.XWPFWordExtractor;
import org.apache.xmlbeans.XmlException;

import java.io.*;
import java.text.SimpleDateFormat;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class TestWordread {
    public static void main(String[] args) throws IOException, OpenXML4JException, XmlException {
////        pdf2word();
//        String text = "";
//        text = readPDF();
////        System.out.println(text);
//        List<Result> results = results(text);
//        ObjectMapper mapper = new ObjectMapper();
//        mapper.setDateFormat(new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"));
//        mapper.disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);
//        String jsonStr = mapper.writeValueAsString(results);
//        System.out.println(jsonStr);
    }

    public static List<Result> results(String text) {
        List<Result> results = new ArrayList<>();
        String paragraph = "(?=知识点 |小试牛刀)([\\s\\S]+?)(?=小试牛刀|知识点 |第二部分 非选择题)";
        Pattern paragraphPattern = Pattern.compile(paragraph);
        String title = "(\\d+\\.[\\S\\s]+?（ ）[\\S\\s]+?)(?=A:)";
        Pattern titlePattern = Pattern.compile(title);
        String option = "([A-D]:\\S+?)\\s";
        Pattern optionPattern = Pattern.compile(option);
        String answer = "【答案】([A-D]+)\\s";
        Pattern answerPattern = Pattern.compile(answer);
        // 不能系统对换行的定义不同
        String reading = "【解析】[\\S \\n\\r]+?。\\r\\n";
        Pattern readingPattern = Pattern.compile(reading);
        String difficulty = "★+";
        Pattern difficultyPattern = Pattern.compile(difficulty);

        Matcher paragraphMatcher = paragraphPattern.matcher(text);
        while (paragraphMatcher.find()) {
            String s = paragraphMatcher.group(1);


            Matcher difficultyMatcher = difficultyPattern.matcher(s);
            int difficultyLevel = 0;
            if (difficultyMatcher.find()) {
                difficultyLevel = difficultyMatcher.group().length();
            }
            Matcher titleMatcher = titlePattern.matcher(s);
            Matcher optionMatcher = optionPattern.matcher(s);
            Matcher answerMatcher = answerPattern.matcher(s);
            Matcher readingMatcher = readingPattern.matcher(s);
            while (titleMatcher.find()) {
                Result result = new Result();

                // 题目
                String titleGroup = titleMatcher.group(1);
                if(titleGroup.contains("【单选题】")){
                    titleGroup.substring(titleGroup.indexOf("【单选题】")).replace("【单选题】", "");
                }
                result.setTitle(titleGroup);

                // 选项
                List<String> options = new ArrayList<>();
                for (int i = 0; i < 4; i++) {
                    if (optionMatcher.find()) {
                        String optionStr = optionMatcher.group(1).replaceAll("\r\n|\r|\n", "");
                        options.add(optionStr);
                    }
                }
                result.setOptions(options);

                // 答案
                if (answerMatcher.find()) {
                    String answerStr = answerMatcher.group(1);
                    result.setAnswer(answerStr);
                }

                // 解析
                if (readingMatcher.find()) {
                    String readingStr = readingMatcher.group();
                    result.setReading(readingStr);
                }

                // 难度
                result.setDifficulty(difficultyLevel);
                results.add(result);
            }
        }
        return results;
    }

    public static String readPDF() throws IOException {
        File file = new File("C:\\Users\\lenovo\\Desktop\\真题.pdf");
        PDDocument document = PDDocument.load(file);
        PDFTextStripper pdfTextStripper = new PDFTextStripper();
        String text = pdfTextStripper.getText(document);
        document.close();
        return text;
    }

    public static String readDocx() throws IOException, OpenXML4JException, XmlException {
        OPCPackage opcPackage = POIXMLDocument.openPackage("C:\\Users\\lenovo\\Desktop\\真题.docx");
        XWPFWordExtractor xwpfWordExtractor = new XWPFWordExtractor(opcPackage);
        String text = xwpfWordExtractor.getText();
        return text;
    }

    public static String readDoc() throws IOException, OpenXML4JException, XmlException {

        File file = new File("C:\\Users\\lenovo\\Desktop\\真题.doc");
        String str = "";
        try {
            FileInputStream fis = new FileInputStream(file);
            HWPFDocument doc = new HWPFDocument(fis);
            String doc1 = doc.getDocumentText();
            System.out.println(doc1);
            StringBuilder doc2 = doc.getText();
            System.out.println(doc2);

            Range rang = doc.getRange();
            String doc3 = rang.text();
            System.out.println(doc3);
            fis.close();
            return doc2.toString();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return str;
    }

    public static void pdf2word() {
        try {
            String pdfFile = "C:\\Users\\lenovo\\Desktop\\真题.pdf";
            PDDocument doc = PDDocument.load(new File(pdfFile));
            int pagenumber = doc.getNumberOfPages();
            pdfFile = pdfFile.substring(0, pdfFile.lastIndexOf("."));
            String fileName = pdfFile + ".doc";
            File file = new File(fileName);
            if (!file.exists()) {
                file.createNewFile();
            }
            FileOutputStream fos = new FileOutputStream(fileName);
            Writer writer = new OutputStreamWriter(fos, "UTF-8");
            PDFTextStripper stripper = new PDFTextStripper();
            stripper.setSortByPosition(true);// 排序
            stripper.setStartPage(1);// 设置转换的开始页
            stripper.setEndPage(pagenumber);// 设置转换的结束页
            stripper.writeText(doc, writer);
            writer.close();
            doc.close();
            System.out.println("pdf转换word成功！");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

class Result {
    private String title;
    private List<String> options;
    private String answer;
    private String reading;
    private Integer difficulty;

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public List<String> getOptions() {
        return options;
    }

    public void setOptions(List<String> options) {
        this.options = options;
    }

    public String getAnswer() {
        return answer;
    }

    public void setAnswer(String answer) {
        this.answer = answer;
    }

    public String getReading() {
        return reading;
    }

    public void setReading(String reading) {
        this.reading = reading;
    }

    public Integer getDifficulty() {
        return difficulty;
    }

    public void setDifficulty(Integer difficulty) {
        this.difficulty = difficulty;
    }

    @Override
    public String toString() {
        return "Result{" +
                "title='" + title + '\'' +
                ", options=" + options.toString() +
                ", answer='" + answer + '\'' +
                ", reading='" + reading + '\'' +
                ", difficulty=" + difficulty +
                '}';
    }
}
```

#### 10，SpringBoot 日期类型参数绑定，序列化

配置类型转换器：

```java
package com.cwj.config.cache;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.convert.converter.Converter;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

@Configuration
public class DateConverterConfig {
    @Bean
    public Converter<String, LocalDate> localDateConverter() {
        return new Converter<String, LocalDate>() {
            @Override
            public LocalDate convert(String source) {
                return LocalDate.parse(source, DateTimeFormatter.ofPattern("yyyy-MM-dd"));
            }
        };
    }

    @Bean
    public Converter<String, LocalDateTime> localDateTimeConverter() {
        return new Converter<String, LocalDateTime>() {
            @Override
            public LocalDateTime convert(String source) {
                return LocalDateTime.parse(source, DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"));
            }
        };
    }

//    @Bean
//    public Converter<String, Date> dateConverter() {
//        return new Converter<String, Date>() {
//            @SneakyThrows
//            @Override
//            public Date convert(String source) {
//                return new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").parse(source);
//            }
//        };
//    }
}
```

配置序列化器：

```java
package com.cwj.config.cache;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.databind.deser.std.DateDeserializers;
import com.fasterxml.jackson.databind.ser.std.DateSerializer;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import com.fasterxml.jackson.datatype.jsr310.deser.LocalDateTimeDeserializer;
import com.fasterxml.jackson.datatype.jsr310.ser.LocalDateTimeSerializer;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.autoconfigure.jackson.Jackson2ObjectMapperBuilderCustomizer;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.converter.json.Jackson2ObjectMapperBuilder;

import java.text.SimpleDateFormat;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Date;

@Configuration
public class LocalDateTimeSerializerConfig {

    @Value("${spring.jackson.date-format:yyyy-MM-dd HH:mm:ss}")
    private String pattern;

    @Bean
    public LocalDateTimeSerializer localDateTimeSerializer() {
        return new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(pattern));
    }

    @Bean
    public DateSerializer dateSerializer() {
        return new DateSerializer(true, new SimpleDateFormat(pattern));
    }

    @Bean
    public Jackson2ObjectMapperBuilderCustomizer jackson2ObjectMapperBuilderCustomizer() {
        return builder -> builder
                .serializerByType(LocalDateTime.class, localDateTimeSerializer())
//                .serializerByType(Date.class, dateSerializer())
                ;
    }

    @Bean
    public ObjectMapper serializingObjectMapper() {
        JavaTimeModule module = new JavaTimeModule();
        LocalDateTimeDeserializer dateTimeDeserializer = new LocalDateTimeDeserializer(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"));
//        MyLocalDateTimeDeserializer myLocalDateTimeDeserializer = new MyLocalDateTimeDeserializer(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"));
        DateDeserializers.DateDeserializer deserializer = new DateDeserializers.DateDeserializer(DateDeserializers.DateDeserializer.instance, new SimpleDateFormat(pattern), pattern);
        module.addDeserializer(LocalDateTime.class, dateTimeDeserializer);
        module.addSerializer(LocalDateTime.class, localDateTimeSerializer());
        module.addSerializer(Date.class, DateSerializer.instance.withFormat(false, new SimpleDateFormat(pattern)));
        module.addDeserializer(Date.class, deserializer);
        return Jackson2ObjectMapperBuilder.json().modules(module)
                .featuresToDisable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS).build();
    }

//    /** 默认日期时间格式 */
//    public static final String DEFAULT_DATE_TIME_FORMAT = "yyyy-MM-dd HH:mm:ss";
//    /** 默认日期格式 */
//    public static final String DEFAULT_DATE_FORMAT = "yyyy-MM-dd";
//    /** 默认时间格式 */
//    public static final String DEFAULT_TIME_FORMAT = "HH:mm:ss";
//
//    @Bean
//    public MappingJackson2HttpMessageConverter mappingJackson2HttpMessageConverter() {
//        MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter();
//        ObjectMapper objectMapper = new ObjectMapper();
//
//        // 忽略json字符串中不识别的属性
//        objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
//        // 忽略无法转换的对象
//        objectMapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false);
//        // PrettyPrinter 格式化输出
//        objectMapper.configure(SerializationFeature.INDENT_OUTPUT, true);
//        // NULL不参与序列化
//        objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);
//
//        // 指定时区
//        objectMapper.setTimeZone(TimeZone.getTimeZone("GMT+8:00"));
//        // 日期类型字符串处理
//        objectMapper.setDateFormat(new SimpleDateFormat(DEFAULT_DATE_TIME_FORMAT));
//
//        // java8日期日期处理
//        JavaTimeModule javaTimeModule = new JavaTimeModule();
//        javaTimeModule.addSerializer(LocalDateTime.class, new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)));
//        javaTimeModule.addSerializer(LocalDate.class, new LocalDateSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)));
//        javaTimeModule.addSerializer(LocalTime.class, new LocalTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)));
//        javaTimeModule.addDeserializer(LocalDateTime.class, new LocalDateTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)));
//        javaTimeModule.addDeserializer(LocalDate.class, new LocalDateDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)));
//        javaTimeModule.addDeserializer(LocalTime.class, new LocalTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)));
//        objectMapper.registerModule(javaTimeModule);
//
//        converter.setObjectMapper(objectMapper);
//        return converter;
//    }
}
```

#### 11，Redis配置序列化为json格式：

```java
package com.cwj.config.cache;

import com.fasterxml.jackson.annotation.JsonAutoDetect;
import com.fasterxml.jackson.annotation.PropertyAccessor;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.cache.RedisCacheConfiguration;
import org.springframework.data.redis.cache.RedisCacheManager;
import org.springframework.data.redis.cache.RedisCacheWriter;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;
import org.springframework.data.redis.serializer.RedisSerializationContext;
import org.springframework.data.redis.serializer.StringRedisSerializer;

import java.net.UnknownHostException;

@Configuration
public class RedisConfig {

    @Bean
    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory redisConnectionFactory) throws UnknownHostException {

        Jackson2JsonRedisSerializer<Object> serializer = new Jackson2JsonRedisSerializer<Object>(Object.class);
        ObjectMapper objectMapper = new ObjectMapper();
        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
        objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
        // 解决jackson2无法反序列化LocalDateTime的问题
        objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
        objectMapper.registerModule(new JavaTimeModule());
        
        serializer.setObjectMapper(objectMapper);

        RedisTemplate<String, Object> redisTemplate = new RedisTemplate<>();
        redisTemplate.setConnectionFactory(redisConnectionFactory);
        redisTemplate.setKeySerializer(new StringRedisSerializer());
        redisTemplate.setValueSerializer(serializer);
        redisTemplate.setHashKeySerializer(new StringRedisSerializer());
        redisTemplate.setHashValueSerializer(serializer);
        redisTemplate.afterPropertiesSet();

        return redisTemplate;
    }

    @Bean
    public RedisCacheManager redisCacheManager(RedisTemplate redisTemplate) {
        RedisCacheWriter redisCacheWriter = RedisCacheWriter.nonLockingRedisCacheWriter(redisTemplate.getConnectionFactory());
        RedisCacheConfiguration redisCacheConfiguration = RedisCacheConfiguration.defaultCacheConfig()
                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(redisTemplate.getValueSerializer()));
        return new RedisCacheManager(redisCacheWriter, redisCacheConfiguration);
    }
}
```

#### 12，SpringSecurity配置请求跨域：

```java
package com.cwj.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpMethod;
import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;

@Configuration
@EnableWebSecurity
@EnableGlobalMethodSecurity(prePostEnabled = true)
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {


    @Override
    protected void configure(HttpSecurity httpSecurity) throws Exception {
//        httpSecurity.cors().configurationSource(corsConfigurationSource());
        httpSecurity.cors().configurationSource(corsConfigurationSource()).and().csrf().disable()
//        httpSecurity.csrf().disable()
                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.NEVER)
                .and().authorizeRequests()
                .antMatchers("/**"
                ).permitAll()
                .antMatchers(HttpMethod.OPTIONS).permitAll()
                .anyRequest().authenticated().and().logout().permitAll();

    }

    @Bean
    CorsConfigurationSource corsConfigurationSource(){
        return httpServletRequest -> {
            CorsConfiguration cfg = new CorsConfiguration();
            cfg.addAllowedHeader("*");
            cfg.addAllowedMethod("*");
            cfg.addAllowedOrigin("*");
            cfg.setAllowCredentials(true);
            cfg.checkOrigin("*");
            return cfg;
        };
    }
}
```

#### 13，数组元素交换的坑

```java
    public static void test01() {
        int[] arr = new int[]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
        System.out.println(Arrays.toString(arr));
        Random random = new Random();
        for (int i = 0; i < arr.length; i++) {
            int r = random.nextInt(arr.length);
            if(i != r){ // 该条件不能省略！因为两数交换是对应两个变量，当i == r时，对一个变量进行交换，结果该变量变成0
                arr[i] = arr[i] ^ arr[r];
            	arr[r] = arr[i] ^ arr[r];
            	arr[i] = arr[i] ^ arr[r];
            }
        }
        System.out.println();
        System.out.println(Arrays.toString(arr));
    }
```

#### 14，Mybatis Example语法

```java
// sql: where (条件1 and 条件2) or (条件3 and 条件4)

//条件1 and 条件2
example.createCriteria()
        .andEqualTo("isDeleted",IsDeleted.NOT_DELETED)
        .andEqualTo("name", projectCatalogEntity.getName());
//or (条件3 and 条件4)
example.or(example.createCriteria()
        .andEqualTo("isDeleted",IsDeleted.NOT_DELETED)
        .andEqualTo("code", projectCatalogEntity.getCode()));

where (条件1 and 条件2) and (条件3 or 条件4)

// sql: 条件1 and 条件2
example.createCriteria()
        .andEqualTo("isDeleted",IsDeleted.NOT_DELETED))
        .andEqualTo("parentId", projectCatalogEntity.getParentId());
//and (条件3 or 条件4)
example.and(example.createCriteria()
        .andEqualTo("name", projectCatalogEntity.getName())
        .orEqualTo("code", projectCatalogEntity.getCode()));

```

#### 15，枚举类的序列化与反序列化

序列化：在枚举类上添加注解：@JsonFormat(shape = JsonFormat.Shape.OBJECT)

反序列化：定义一个被注解：@JsonCreator 修饰的方法用于反序列化

```java
@Getter
@JsonFormat(shape = JsonFormat.Shape.OBJECT)
public enum DeleteEnum implements BasicEnum {
    //
    NOT_DELETE(1, "NOT_DELETE", "未删除"),
    DELETED(2, "DELETED", "已删除");

    private int code;
    private String logContent;
    private String description;

    DeleteEnum(final int code, final String logContent, final String description) {
        this.code = code;
        this.logContent = logContent;
        this.description = description;
    }

    /**
     * 用于保存所有的枚举值
     */
    private static Map<String, DeleteEnum> RESOURCE_MAP = Stream
            .of(DeleteEnum.values())
            .collect(Collectors.toMap(s -> s.getLogContent(), Function.identity()));


    /**
     * 枚举反序列话调用该方法
     *
     * @param jsonNode
     * @return
     */
    @JsonCreator //必须修饰static方法
    public static DeleteEnum des(final JsonNode jsonNode) {
        return Optional
                .ofNullable(RESOURCE_MAP.get(jsonNode.get("logContent").asText()))
                .orElseThrow(() -> new IllegalArgumentException(jsonNode.get("logContent").asText()));
    }

}
```

#### 16，logback-spring.xml配置

```xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration scan="true" scanPeriod="10 seconds">
    <!-- 日志级别从低到高分为TRACE < DEBUG < INFO < WARN < ERROR < FATAL，如果设置为WARN，则低于WARN的信息都不会输出 -->
    <!-- scan:当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true -->
    <!-- scanPeriod:设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当scan为true时，此属性生效。默认的时间间隔为1分钟。 -->
    <!-- debug:当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。 -->
    <contextName>logback</contextName>

    <property name="APP_NAME" value="myApp"/><!-- 项目名 -->
    <property name="LOG_HOME_DEV" value="./logs"/><!-- 本地运行环境 -->
    <property name="LOG_HOME_TEST" value="/home/logs/${APP_NAME}"/><!--test环境 -->
    <property name="LOG_HOME_PROD" value="/logs/${APP_NAME}"/><!-- 生产环境 -->
    <springProfile name="dev">
        <property name="LOG_HOME" value="${LOG_HOME_DEV}"/><!-- 本地运行环境 -->
    </springProfile>
    <springProfile name="prod">
        <property name="LOG_HOME" value="${LOG_HOME_PROD}"/><!-- 本地运行环境 -->
    </springProfile>
    <springProfile name="test">
        <property name="LOG_HOME" value="${LOG_HOME_TEST}"/><!-- 本地运行环境 -->
    </springProfile>

    <!-- 彩色日志 -->
    <!-- 配置格式变量：CONSOLE_LOG_PATTERN 彩色日志格式 -->
    <!-- magenta:洋红 -->
    <!-- boldMagenta:粗红-->
    <!-- cyan:青色 -->
    <!-- white:白色 -->
    <!-- magenta:洋红 -->
    <property name="CONSOLE_LOG_PATTERN"
              value="%yellow(%date{yyyy-MM-dd HH:mm:ss}) |%highlight(%-5level) |%blue(%thread) |%blue(%file:%line) |%green(%logger) |%cyan(%msg%n)"/>


    <!--输出到控制台-->
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <!--此日志appender是为开发使用，只配置最底级别，控制台输出的日志级别是大于或等于此级别的日志信息-->
        <!-- 例如：如果此处配置了INFO级别，则后面其他位置即使配置了DEBUG级别的日志，也不会被输出 -->
<!--        <filter class="ch.qos.logback.classic.filter.ThresholdFilter">-->
<!--            <level>INFO</level>-->
<!--        </filter>-->
        <encoder>
            <Pattern>${CONSOLE_LOG_PATTERN}</Pattern>
            <!-- 设置字符集 -->
            <charset>UTF-8</charset>
        </encoder>
    </appender>


    <!--输出到文件-->
    <springProfile name="dev | test">
        <appender name="CONSOLE_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
            <!-- 正在记录的日志文件的路径及文件名 -->
            <file>${LOG_HOME}/log_console.log</file>
            <!--日志文件输出格式-->
            <encoder>
                <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n</pattern>
                <charset>UTF-8</charset>
            </encoder>
            <!-- 日志记录器的滚动策略，按日期，按大小记录 -->
            <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
                <!-- 每天日志归档路径以及格式 -->
                <fileNamePattern>${LOG_HOME}/%d{yyyy-MM-dd}/console/log-console-%d{yyyy-MM-dd}.%i.log</fileNamePattern>
                <timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP">
                    <maxFileSize>100MB</maxFileSize>
                </timeBasedFileNamingAndTriggeringPolicy>
                <!--日志文件保留天数-->
                <maxHistory>15</maxHistory>
            </rollingPolicy>
            <!-- 此日志文件只记录info级别的 -->
            <filter class="ch.qos.logback.classic.filter.LevelFilter">
                <level>DEBUG</level>
<!--                <onMatch>ACCEPT</onMatch>-->
<!--                <onMismatch>DENY</onMismatch>-->
            </filter>
        </appender>
    </springProfile>
    <!-- 时间滚动输出 level为 INFO 日志 -->
    <appender name="INFO_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <!-- 正在记录的日志文件的路径及文件名 -->
        <file>${LOG_HOME}/log_info.log</file>
        <!--日志文件输出格式-->
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n</pattern>
            <charset>UTF-8</charset>
        </encoder>
        <!-- 日志记录器的滚动策略，按日期，按大小记录 -->
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <!-- 每天日志归档路径以及格式 -->
            <fileNamePattern>${LOG_HOME}/%d{yyyy-MM-dd}/info/log-info-%d{yyyy-MM-dd}.%i.log</fileNamePattern>
            <timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP">
                <maxFileSize>100MB</maxFileSize>
            </timeBasedFileNamingAndTriggeringPolicy>
            <!--日志文件保留天数-->
            <maxHistory>15</maxHistory>
        </rollingPolicy>
        <!-- 此日志文件只记录info级别的 -->
        <filter class="ch.qos.logback.classic.filter.LevelFilter">
            <level>INFO</level>
            <onMatch>ACCEPT</onMatch>
            <onMismatch>DENY</onMismatch>
        </filter>
    </appender>

    <!-- 时间滚动输出 level为 WARN 日志 -->
    <appender name="WARN_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <!-- 正在记录的日志文件的路径及文件名 -->
        <file>${LOG_HOME}/log_warn.log</file>
        <!--日志文件输出格式-->
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n</pattern>
            <charset>UTF-8</charset> <!-- 此处设置字符集 -->
        </encoder>
        <!-- 日志记录器的滚动策略，按日期，按大小记录 -->
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>${LOG_HOME}/%d{yyyy-MM-dd}/warn/log-warn-%d{yyyy-MM-dd}.%i.log</fileNamePattern>
            <timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP">
                <maxFileSize>100MB</maxFileSize>
            </timeBasedFileNamingAndTriggeringPolicy>
            <!--日志文件保留天数-->
            <maxHistory>15</maxHistory>
        </rollingPolicy>
        <!-- 此日志文件只记录warn级别的 -->
        <filter class="ch.qos.logback.classic.filter.LevelFilter">
            <level>WARN</level>
            <onMatch>ACCEPT</onMatch>
            <onMismatch>DENY</onMismatch>
        </filter>
    </appender>


    <!-- 时间滚动输出 level为 ERROR 日志 -->
    <appender name="ERROR_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <!-- 正在记录的日志文件的路径及文件名 -->
        <file>${LOG_HOME}/log_error.log</file>
        <!--日志文件输出格式-->
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n</pattern>
            <charset>UTF-8</charset> <!-- 此处设置字符集 -->
        </encoder>
        <!-- 日志记录器的滚动策略，按日期，按大小记录 -->
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>${LOG_HOME}/%d{yyyy-MM-dd}/error/log-error-%d{yyyy-MM-dd}.%i.log</fileNamePattern>
            <timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP">
                <maxFileSize>100MB</maxFileSize>
            </timeBasedFileNamingAndTriggeringPolicy>
            <!--日志文件保留天数-->
            <maxHistory>15</maxHistory>
        </rollingPolicy>
        <!-- 此日志文件只记录ERROR级别的 -->
        <filter class="ch.qos.logback.classic.filter.LevelFilter">
            <level>ERROR</level>
            <onMatch>ACCEPT</onMatch>
            <onMismatch>DENY</onMismatch>
        </filter>
    </appender>

    <!--
        <logger>用来设置某一个包或者具体的某一个类的日志打印级别、以及指定<appender>。
        <logger>仅有一个name属性，
        一个可选的level和一个可选的addtivity属性。
        name:用来指定受此logger约束的某一个包或者具体的某一个类。
        level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF，
              如果未设置此属性，那么当前logger将会继承上级的级别。
    -->
    <!--
        使用mybatis的时候，sql语句是debug下才会打印，而这里我们只配置了info，所以想要查看sql语句的话，有以下两种操作：
        第一种把<root level="INFO">改成<root level="DEBUG">这样就会打印sql，不过这样日志那边会出现很多其他消息
        第二种就是单独给mapper下目录配置DEBUG模式，代码如下，这样配置sql语句会打印，其他还是正常DEBUG级别：
     -->
    <!--可以输出项目中的debug日志，包括mybatis的sql日志-->
<!--    <logger name="com.unicom.uac.mapper" level="DEBUG" addtivity="false" />-->
    <!--
        root节点是必选节点，用来指定最基础的日志输出级别，只有一个level属性
        level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF，默认是DEBUG
        可以包含零个或多个appender元素。
    -->
    <logger name="com.cwj" level="DEBUG" addtivity="false" />
    <logger name="com.cwj.mapper" level="DEBUG" addtivity="false" />
    <root level="INFO">
        <appender-ref ref="CONSOLE" />
        <springProfile name="dev | test">
            <appender-ref ref="CONSOLE_FILE" />
        </springProfile>
        <appender-ref ref="INFO_FILE" />
        <appender-ref ref="WARN_FILE" />
        <appender-ref ref="ERROR_FILE" />
    </root>

</configuration>
```

#### 17，ThreadLocal源码

ThreadLocal内存模型：

创建ThreadLocal对象后，调用set方法时，会先获取当前线程对象，判断当前线程对象中的属性（ThreadLocal.ThreadLocalMap）threadLocals是否为null，如果为空，则创建并设置初始值：key=当前

ThreadLocal对象，value=set(value);

![image-20201010144541013](%E7%AC%94%E8%AE%B0.assets/image-20201010144541013.png)

通过内存模型分析：当当前ThreadLocal对象使用完毕后，除了ThreadLocalMap中的Entity.key持有弱引用之外，没有别的对象再持有该对象的引用，则会在GC发生时对弱引用对象进行垃圾回收。此时，Enity.key = null，当前线程还在运行时，因为当前线程一直持有Entity的强引用。所以Entity不会被回收。这就造成内存泄漏风险。

即使Entity的key引用改成强引用，也是如此。内存泄漏发生的原因有两点：

1. Entity没有被remove;
2. 当前线程一直在运行；

防止内存泄漏的手段：

及时remove掉不再使用的entity;

问题1：ThreadLocal使用弱引用的是什么？

尽可能避免内存泄漏发生的机率；当弱引用被GC回收后，key=null,则在下一次调用ThreadLocal中的set/get/remvoe方法时，都会对key=null做判断，如果key=null,则value=null,即使当前线程依然在运行，key,value指向的对象已经被回收，避免内存泄漏。

问题2：ThreadLocal如果解决hash冲突的？

1. 通过魔法数字0x61c88647（斐波那契数列，黄金分割）生成key的hash，使其hash均匀的分布；
2. 通过hash & (len -1) 【len为2的幂】均匀的分布在数组下标上。
3. 通过线性探测法彻底避免hash冲突。

#### 18，文件二进制加密

```java
package com.cwj;

import java.io.*;

/**
 * @author chenwujie
 * @date 2020/10/1415:18
 */
public class FileEncrypt {
    private static int mask = 0b1011_0110;
    public static void main(String[] args) throws IOException {
        String srcPath = "C:\\VScodeProjects\\pythonPros\\fileEnpyro\\山水.jpg";
        String encryptPath = "C:\\VScodeProjects\\pythonPros\\fileEnpyro\\山水副本.jpg";
        String decryptPath = "C:\\VScodeProjects\\pythonPros\\fileEnpyro\\山水副本2.jpg";
//        encryptOrDecrypt(srcPath, encryptPath);
        encryptOrDecrypt(encryptPath, decryptPath);

    }

    /**
     * 文件加/解密
     * 对源文件数据用掩码进行异或运算（对源文件进行两次运算可以得到源文件相同信息）；
     * @param src   源文件路径
     * @param path_new 新文件路径
     * @throws IOException
     */
    public static void encryptOrDecrypt(String src, String path_new) throws IOException {
        File file = new File(src);
        File file2 = new File(path_new);
        FileInputStream inputStream = new FileInputStream(file);
        FileOutputStream outputStream = new FileOutputStream(file2);

        int data = 0;
        while((data = inputStream.read()) > -1){
            outputStream.write(data ^ mask);
        }

        inputStream.close();
        outputStream.flush();
        outputStream.close();
    }

    /**
     * 对字节数组加/解密
     * @param src 源文件字节数组
     * @return 返回新的数组
     */
    public static byte[] encryptOrDecrypt(byte[] src){
        if(src == null){
            return null;
        }
        byte[] data = new byte[src.length];
        for(int i = 0; i < src.length; i++){
            data[i] = (byte)(src[i] ^ mask);
        }
        return data;
    }
}
```

