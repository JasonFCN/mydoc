<<<<<<< HEAD
面试题

1. Java多线程有几种实现方式？
    - 继承Thread类
    - 实现Runnable接口
    - 实现Callable接口，通过FutureTask获取执行结果
    - 线程池

2. 为什么不建议使用Executors创建线程池？

    Executors.newCachedThreadPool和Executors.newScheduledThreadPool创建的线程池的最大线程数都是Integer.MAX_VALUE，对线程数量没有限制，不利于管理。

    Executors.newSingleThreadPool和Executors.newFixedThreadPool创建的线程池的工作队列容量都是Integer.MAX_VALUE，如果内存堆积太多任务，容易OOM。

    更重要的是，针对不同的应用场景，我们需要结合实际业务，配置合适的线程池参数，管理我们的应用程序，使程序更合理的利用系统资源。

3. 线程池的参数有哪些？

    核心线程数：常驻线程数

    最大线程数：用来处理任务缓存队列已满的任务。

    工作队列：缓存任务

    线程工厂：创建线程，生成统一格式的线程名称，便于排查

    线程空闲时间：大于核心线程数再创建的线程，超过该时间后，线程销毁。如果allowCoreThreadTimeout设置为ture，核心线程也会销毁。

    时间单位：

    拒绝策略：当缓存队列已满，已达到最大线程数，会拒绝新的任务。默认抛出异常。

4. 线程池任务提交的流程？

    当工作线程小于核心线程数时，创建新的线程处理新任务。当工作线程等于核心线程数时，放入工作队列，如果工作队列已满，创建新的临时线程处理新任务。如果工作线程数等于最大线程数，触发拒绝策略。

5. 线程池的拒绝策略有哪几种？

    抛出异常（默认）

    直接抛弃该任务

    抛弃队列中最久的任务

    交给调用者线程处理

    自定义拒绝策略（记录日志，存入数据库，放入MQ等）

6. AQS的原理

    在AQS中，使用一个volatile修饰的int值来表示锁状态。同时也维护了一个等待队列。队列中的节点维护了一个waitStatus int类型字段，用来表示节点当前的状态。

7. AQS中使用到的设计模式

    采用模板方法的设计模式，把逻辑封装在AQS内部，提供一个方法供子类实现，来完成特定的需求。如实现公平与非公平

8. 读写锁的实现方式

    通过位运算方式共享一个state值。高16位为读锁，低16位为写锁。读锁为共享模式，写锁为独占模式。为了减少写饥饿问题，在获取读锁时，会先判断一下AQS队列中第一个排队的节点是否是写线程。如果是则排队，较少对写锁获取的争抢。

9. AQS的尾分叉

    AQS的等待队列在插入到尾部的时候，会设置tail变量指向要去排队的节点，但是只有一个能成功。如果这时从头部遍历链表的话，就会导致遍历不到所有节点；相反，如果从尾部遍历的话，可以可以遍历到全部入队的节点。

10. synchronized锁升级过程

    当第一个线程初次获取锁的时候（标志位：001），会在对象头中设置为偏向锁标志101，并在对象头中设置当前线程指针。当该过程中发现竞争，会升级为自旋锁，通过自旋来完成锁获取。当自旋也获取失败时，就会使用操作系统的互斥锁，升级为重量级锁。

11. 适应性自旋锁

    虽然自旋锁避免了使用重量级锁带来性能开销，但是自旋多少次，并不是一个确定的值，所以引入了自适应性，即根据上次成功自旋，则可能这次也会成功。所以会给更多的自旋次数。相反，如果上次经常自旋失败，这次会减少自旋次数。

12. ConcurrentHashMap在JDK7,和8中的变化

    1.7使用锁分段技术，减小锁粒度来提高并发度。1.8采用CAS+synchronized来实现。

11. CAS是什么？

    比较并交换，是操作系统提供的一个操作原语。这个操作，是原子性的。

12. CAS存在的问题

    自旋时间过长。使用阻塞原语

    ABA，使用版本号

    高并发场景不太适合

13. LongAdder

    刚开始对base来进行一个并发操作。当并发度太高时，采用Cell来完成。同一个Cell中进行累加。最终的值就是所有Cell值的总和。当然也使用了缓存行对齐来避免伪共享对性能的影响。

14. HashMap的加载因子为什么是0.75

    跟泊松分布有关。

15. HashMap在1.8中节点采用什么插法？

    采用尾查法。原因是采用头插法，会在多线程情况下，导致出现循环链表。不过这种问题，根源还是编码的错误造成的。

16. Spring中@Autowired和@Resource区别

    @Autowired由Spring提供，只按类型注入。如果想按名称注入，使用@Qualifier注解

    @Resoure由2EE标准提供，按名称注入，当不能注入时，尝试按类型注入。如果指定了name，则只能按照该name注入。
























=======
#### Spring循环依赖：

通过递归方式，先实例化目标对象，再实例化依赖对象。

#### DI和ioc是什么

#### Spring常用的设计模式

单例模式：

工厂模式：

代理模式：

模板方法：

观察者：

#### 单例模式如何保证线程安全

DCL，不推荐

类加载机制

枚举

#### SpringMVC流程：

1.在DispatcherServlet中调用handlerMapping处理器映射器方法，找到具体的处理器代理对象；

调用handlerAdapter处理器适配器

调用具体的处理器；

返回ModelAndView；

DispatcherServlet将视图传给视图解析器解析；

解析出具体的View；

对试图进行渲染；

响应给用户；

#### SpringCloud常用组件

Eureka:服务注册与发现

Zuul：网关；阻塞式网络模型；

Ribbon: 客户端负载均衡

Feign: 声明式Web服务客户端

Hystrix: 

​	服务降级：当发生以下情况时，快速返回一个友好的提示：

​					程序运行异常|超时|服务熔断|限流

​	服务限流：信号量

​	服务熔断：断路器基于三种状态打开，关闭，半开；

Config: 配置中心

#### zookepper

持久节点：

临时节点：

TTL：可以对一个键或目录设置一个存活时间。当指定时间内没有更新并且没有子节点，这个节点将在服务端删除。

watch机制：

zk分布式锁机制：一种是在根目录创建一个临时节点，成功创建则代表拥有锁；同时有其他线程在创建该节点，但失败，则会watch该节点。（注意惊群现象）

另一种是创建一个顺序节点，每个后继节点去watch前驱节点。

选举机制：

启动选举：每个节点都投票给自己，然后进行pk,根据事务id和myid。相同事务id比较myid。myid最大的胜出。

崩溃选举：leader故障后，从节点进入looking状态；各节点投票，先投自己，再广播；接收到的广播信息，进行对比，如果本节点小，改变投票信息为接收到的信息，重新广播；统计本地投票，超半数节点切换为leading状态并广播。

zab协议：包含了两种模式：崩溃恢复和消息广播；

集群中的事务都由Leader节点处理。事务消息要广播给其他节点。其他节点回复。收到多半数回复后，会再次广播commit消息，确认之前的提交。

在以下情况中会崩溃恢复：初始化集群；Leader崩溃；Leader失去半数支持。

#### 分布式集群中为什么要有主节点？

减少重复计算

长连接的TCP，分包方式：

固定消息长度；特殊字符作为消息边界；消息头添加一个消息长度字段；利用格式标识（解析该格式使用状态机）

#### Netty的实现原理：

采用NIO+reactorIO模型
Netty中修复了NIO中的一个什么Bug?

epoll中Selector空轮询的bug。解决方式记录轮询次数，当达到512次后，将Selector中的Channel从新注册到新的Selector上，关掉原理的Selector;

#### JVM主要包含哪些东西：

JVM运行时数据区：

堆，方法区，虚拟机栈，本地方法栈，程序计数器

类加载机制

字节码执行引擎

本地方法库接口

垃圾收集

编译器

垃圾收集算法：

复制；标记清除；标记整理；分代收集。

#### kakfa是如何实现高吞吐

顺序写；预读；零拷贝；

kafka消息丢失：同步模式下，设置ACK为-1；异步模式下，设置生产者一直阻塞；

消息重复消费：幂等性校验。

redis常见的问题：

雪崩：redis大量的key在相同时间内失效，导致请求都打到数据库；

解决：随机设置过期时间。不设置过期；定时刷新缓存；

穿透：非常规场景下，非法key由于不存在于reids导致会查询数据库；

解决：布隆过滤器；参数校验；

击穿：高并发情况下，一个key失效后，大量请求打到数据库库；

解决：设置热点key永不过期；加互斥锁；

#### ES路由分片算法：

文档id哈希取模；

#### redis数据结构：

#### Mysql优化流程：

1. 开启慢查询;set global slow_query_log = 1;slow_query_log_file=路径

2. Explain分析sql执行计划

   重点关注：select_type;possible_keys;key;key_len;extra: using filesort|using temporary

   using filesort: 

   ​	order by 字段不是索引字段

   ​	order by 字段是索引字段，但select中没有使用覆盖索引；

   ​	order by 中同时存在升序和降序；

   ​	order by 中字段未按照最左前缀法则

   using temporary:

   ​	使用as作为一个临时表的时候，结果集也比较大的时候；

   Mysql索引数据结构：

   B+树：因为B+树所有数据存在于叶子节点，并且叶子节点已经被排序；这样可以进行范围查找；同时可以预读数据；

   

   
>>>>>>> 7a7e8b537272a2926ed582667c54727663fce6f5



