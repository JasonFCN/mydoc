面试题

1. Java多线程有几种实现方式？
    - 继承Thread类
    - 实现Runnable接口
    - 实现Callable接口，通过FutureTask获取执行结果
    - 线程池

2. 为什么不建议使用Executors创建线程池？

    Executors.newCachedThreadPool和Executors.newScheduledThreadPool创建的线程池的最大线程数都是Integer.MAX_VALUE，对线程数量没有限制，不利于管理。

    Executors.newSingleThreadPool和Executors.newFixedThreadPool创建的线程池的工作队列容量都是Integer.MAX_VALUE，如果内存堆积太多任务，容易OOM。

    更重要的是，针对不同的应用场景，我们需要结合实际业务，配置合适的线程池参数，管理我们的应用程序，使程序更合理的利用系统资源。

3. 线程池的参数有哪些？

    核心线程数：常驻线程数

    最大线程数：用来处理任务缓存队列已满的任务。

    工作队列：缓存任务

    线程工厂：创建线程，生成统一格式的线程名称，便于排查

    线程空闲时间：大于核心线程数再创建的线程，超过该时间后，线程销毁。如果allowCoreThreadTimeout设置为ture，核心线程也会销毁。

    时间单位：

    拒绝策略：当缓存队列已满，已达到最大线程数，会拒绝新的任务。默认抛出异常。

4. 线程池任务提交的流程？

    当工作线程小于核心线程数时，创建新的线程处理新任务。当工作线程等于核心线程数时，放入工作队列，如果工作队列已满，创建新的临时线程处理新任务。如果工作线程数等于最大线程数，触发拒绝策略。

5. 线程池的拒绝策略有哪几种？

    抛出异常（默认）

    直接抛弃该任务

    抛弃队列中最久的任务

    交给调用者线程处理

    自定义拒绝策略（记录日志，存入数据库，放入MQ等）

6. AQS的原理

    在AQS中，使用一个volatile修饰的int值来表示锁状态。同时也维护了一个等待队列。队列中的节点维护了一个waitStatus int类型字段，用来表示节点当前的状态。

7. AQS中使用到的设计模式

    采用模板方法的设计模式，把逻辑封装在AQS内部，提供一个方法供子类实现，来完成特定的需求。如实现公平与非公平

8. 读写锁的实现方式

    通过位运算方式共享一个state值。高16位为读锁，低16位为写锁。读锁为共享模式，写锁为独占模式。为了减少写饥饿问题，在获取读锁时，会先判断一下AQS队列中第一个排队的节点是否是写线程。如果是则排队，较少对写锁获取的争抢。

9. AQS的尾分叉

    AQS的等待队列在插入到尾部的时候，会设置tail变量指向要去排队的节点，但是只有一个能成功。如果这时从头部遍历链表的话，就会导致遍历不到所有节点；相反，如果从尾部遍历的话，可以可以遍历到全部入队的节点。

10. synchronized锁升级过程

    当第一个线程初次获取锁的时候（标志位：001），会在对象头中设置为偏向锁标志101，并在对象头中设置当前线程指针。当该过程中发现竞争，会升级为自旋锁，通过自旋来完成锁获取。当自旋也获取失败时，就会使用操作系统的互斥锁，升级为重量级锁。

11. 适应性自旋锁

    虽然自旋锁避免了使用重量级锁带来性能开销，但是自旋多少次，并不是一个确定的值，所以引入了自适应性，即根据上次成功自旋，则可能这次也会成功。所以会给更多的自旋次数。相反，如果上次经常自旋失败，这次会减少自旋次数。

12. ConcurrentHashMap在JDK7,和8中的变化

    1.7使用锁分段技术，减小锁粒度来提高并发度。1.8采用CAS+synchronized来实现。

11. CAS是什么？

    比较并交换，是操作系统提供的一个操作原语。这个操作，是原子性的。

12. CAS存在的问题

    自旋时间过长。使用阻塞原语

    ABA，使用版本号

    高并发场景不太适合

13. LongAdder

    刚开始对base来进行一个并发操作。当并发度太高时，采用Cell来完成。同一个Cell中进行累加。最终的值就是所有Cell值的总和。当然也使用了缓存行对齐来避免伪共享对性能的影响。

14. HashMap的加载因子为什么是0.75

    跟泊松分布有关。

15. HashMap在1.8中节点采用什么插法？

    采用尾查法。原因是采用头插法，会在多线程情况下，导致出现循环链表。不过这种问题，根源还是编码的错误造成的。

16. Spring中@Autowired和@Resource区别

    @Autowired由Spring提供，只按类型注入。如果想按名称注入，使用@Qualifier注解

    @Resoure由2EE标准提供，按名称注入，当不能注入时，尝试按类型注入。如果指定了name，则只能按照该name注入。



























