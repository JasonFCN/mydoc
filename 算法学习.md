#### 栈：Stack

栈与递归是紧密相连的。递归思想本质就是对子问题入栈，再依次出栈求解。

例子：二叉树的后序遍历问题

递归算法：

```java
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<Integer>();
        postorder(root, res);
        return res;
    }

    public void postorder(TreeNode root, List<Integer> res) {
        if (root == null) {
            return;
        }
        postorder(root.left, res);
        postorder(root.right, res);
        res.add(root.val);
    }
}
```

迭代算法：

```java
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<Integer>();
        if (root == null) {
            return res;
        }

        Deque<TreeNode> stack = new LinkedList<TreeNode>();
        TreeNode prev = null;
        while (root != null || !stack.isEmpty()) {
            while (root != null) {
                stack.push(root);
                root = root.left;
            }
            root = stack.pop();
            if (root.right == null || root.right == prev) {
                res.add(root.val);
                prev = root;
                root = null;
            } else {
                stack.push(root);
                root = root.right;
            }
        }
        return res;
    }
}
```

用迭代显式的实现递归思路：

1. 每拿到一个节 就把它保存在栈中
2. 继续对这个节点的 左子树 重复 过程1，直到左子树为 空
3. 因为保存在 栈 中的节点都遍历了 左子树 但是没有遍历 右子树，所以对栈中节点 出栈 并对它的 右子树 重复 过程1
4. 直到遍历完所有节点

单调栈：

#### 位运算：

与、或、取反、异或、左移、有符号右移、无符号右移

| 符号 | 名称       | 描述                                      |
| ---- | ---------- | ----------------------------------------- |
| &    | 与         | 两个bit位同为1，结果才为1                 |
| \|   | 或         | 只要存在一个bit位为1，结果就为1           |
| ~    | 取反       | 0变成1，1变成0                            |
| ^    | 异或       | bit位相同，结果为0；bit不同，结果为1      |
| <<   | 左移       | bit向左移动若干位，高位舍弃，低位补0      |
| >>   | 有符号右移 | bit向右移动若干位，低位舍弃，高位补符号位 |
| >>>  | 无符号右移 | bit向右移动若干位，低位舍弃，高位补0      |

##### java基本类型的二进制存储

```txt
以int类型为例：
    int a1 = 3;
    int b2 = 0b0000_0000_0000_0000_0000_0000_0000_0011;
    int b1 = -1;
    int b2 = 0b1111_1111_1111_1111_1111_1111_1111_1111;
    int c1 = -3;
    int c2 = 0b1111_1111_1111_1111_1111_1111_1111_1101;
原码：一个数的绝对值
反码：原码取反
补码：原码取反，再加1
例如：-3
-3原码：0b0000_0000_0000_0000_0000_0000_0000_0011;
-3反码：0b1111_1111_1111_1111_1111_1111_1111_1100;
-3补码：0b1111_1111_1111_1111_1111_1111_1111_1101;
```

##### 不同基本类型的按位运算

```java
boolean b1 = true;
boolean b2 = false;
//int b3 = b1 ^ b2; // 编译错误 b1 ^ b2的结果是boolean类型
System.out.println(b1 ^ b2);
//System.out.println(b1 ^ 2); // 编译错误 Operator '^' cannot be applied to 'boolean', 'int'
//System.out.println(~b1); // 编译错误 Operator '~' cannot be applied to 'boolean'
byte bt1 = 3;
byte bt2 = 2;
//byte bt3 = bt1 ^ bt2; // 编译错误 bt1 ^ bt2 的结果类型为int
int bt3 = bt1 ^ bt2;
System.out.println(bt1 ^ bt2); // 结果：1
System.out.println(3 ^ bt2); // 结果：1
byte bt4 = -3;
System.out.println(bt4 ^ bt2); // 结果：-1
System.out.println(-3 ^ bt2); // 结果：-1
```

1. 布尔类型的按位运算没有取反运算；布尔类型不能与其他类型进行按位运算。
2. byte、char等类型的按位运算，结果类型为int类型；先将byte、char等类型转换成int，再运算。
3. 与long类型进行按位运算，结果类型为long类型；先将byte、int 等类型转换成long，再运算。

##### 按位与（&）：

真值表：

| a    | b    | 结果 |
| ---- | ---- | ---- |
| 0    | 0    | 0    |
| 0    | 1    | 0    |
| 1    | 0    | 0    |
| 1    | 1    | 1    |

用途：

1. 复位；n & 0 = 0
2. 截取固定bit位 ；n & (m - 1)  = n的m低位表示
3. 奇偶判断；n & 1 = =1，则表示n 为基数；n & 1 == 0，则n为偶数。

##### 按位或（|）：

真值表：

| a    | b    | 结果 |
| ---- | ---- | ---- |
| 0    | 0    | 0    |
| 0    | 1    | 1    |
| 1    | 0    | 1    |
| 1    | 1    | 1    |

用途：

1. 设置bit位为1；n = n | 0b1111 ，则n的低4位 置为1。

##### 按位异或（^）：

真值表：

| a    | b    | 结果 |
| ---- | ---- | ---- |
| 0    | 0    | 0    |
| 0    | 1    | 1    |
| 1    | 0    | 1    |
| 1    | 1    | 0    |

性质：

1. 交换律；a  ^ b == b ^ a
2. 结合律；a ^ b ^ c == b ^ c ^ a
3. a ^ a = 0
4. a ^ 0 = a
5. a ^ -1 = ~a

用途：

1. 两个数交换a,b
   a ^= b;
   b ^= a;
   a ^= b;
2. 反转bit位
   n = 0b1010, n ^= 0b1111，则n的低四位被反转，n = 0b0101
3. 找不同
   n ^ m = x ，则x为1的bit位则表示n与m在此位置的bit位不相同。

##### 按位取反（～）：

真值表：

| a    | 结果 |
| ---- | ---- |
| 0    | 1    |
| 1    | 0    |

用途：

负数求绝对值；|n| = ~(n - 1)

##### 左移（<<）:

一个数的bit位向左移动n位，左边n位舍去，右边n位补0；

##### 有符号右移（>>）：

一个数的bit位向右移动n位，右边n位舍去，左边n位正数补0，负数补1；

##### 无符号右移动（>>>）：

一个数的bit位向右移动n位，右边n位舍去，左边n位补0；

###### **>>** 与  >>> 比较

```txt
00110111000111110110110101010101 正数

00001101110001111101101101010101 正数 >> 2

00001101110001111101101101010101 正数 >>> 2


10110111000111110110110101010101 负数

11101101110001111101101101010101 负数 >> 2

00101101110001111101101101010101 负数 >>> 2
```

有符号右移：位移n位后，空位补上符号位【正数补0，负数补1】

无符号右移：位移n位后，空位直接补0，不区分正负号



位运算求最值：

使用if-else或其他比较运算符

```java
public int maximum(int a, int b) {
        // 先考虑没有溢出时的情况，计算 b - a 的最高位，依照题目所给提示 k = 1 时 a > b，即 b - a 为负
         int k = b - a >>> 31;
         // 再考虑 a b 异号的情况，此时无脑选是正号的数字
         int aSign = a >>> 31, bSign = b >>> 31;
         // diff = 0 时同号，diff = 1 时异号
         int diff = aSign ^ bSign;
         // 在异号，即 diff = 1 时，使之前算出的 k 无效，只考虑两个数字的正负关系
         k = k & (diff ^ 1) | bSign & diff;
         return a * k + b * (k ^ 1);
    }
```

