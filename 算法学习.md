#### 栈：Stack

栈与递归是紧密相连的。递归思想本质就是对子问题入栈，再依次出栈求解。

例子：二叉树的后序遍历问题

递归算法：

```java
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<Integer>();
        postorder(root, res);
        return res;
    }

    public void postorder(TreeNode root, List<Integer> res) {
        if (root == null) {
            return;
        }
        postorder(root.left, res);
        postorder(root.right, res);
        res.add(root.val);
    }
}
```

迭代算法：

```java
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<Integer>();
        if (root == null) {
            return res;
        }

        Deque<TreeNode> stack = new LinkedList<TreeNode>();
        TreeNode prev = null;
        while (root != null || !stack.isEmpty()) {
            while (root != null) {
                stack.push(root);
                root = root.left;
            }
            root = stack.pop();
            if (root.right == null || root.right == prev) {
                res.add(root.val);
                prev = root;
                root = null;
            } else {
                stack.push(root);
                root = root.right;
            }
        }
        return res;
    }
}
```

用迭代显式的实现递归思路：

1. 每拿到一个节 就把它保存在栈中
2. 继续对这个节点的 左子树 重复 过程1，直到左子树为 空
3. 因为保存在 栈 中的节点都遍历了 左子树 但是没有遍历 右子树，所以对栈中节点 出栈 并对它的 右子树 重复 过程1
4. 直到遍历完所有节点

单调栈：

#### 位运算：

与、或、取反、异或、左移、有符号右移、无符号右移

| 符号 | 名称       | 描述                                      |
| ---- | ---------- | ----------------------------------------- |
| &    | 与         | 两个bit位同为1，结果才为1                 |
| \|   | 或         | 只要存在一个bit位为1，结果就为1           |
| ~    | 取反       | 0变成1，1变成0                            |
| ^    | 异或       | bit位相同，结果为0；bit不同，结果为1      |
| <<   | 左移       | bit向左移动若干位，高位舍弃，低位补0      |
| >>   | 有符号右移 | bit向右移动若干位，低位舍弃，高位补符号位 |
| >>>  | 无符号右移 | bit向右移动若干位，低位舍弃，高位补0      |

##### java基本类型的二进制存储

```txt
以int类型为例：
    int a1 = 3;
    int b2 = 0b0000_0000_0000_0000_0000_0000_0000_0011;
    int b1 = -1;
    int b2 = 0b1111_1111_1111_1111_1111_1111_1111_1111;
    int c1 = -3;
    int c2 = 0b1111_1111_1111_1111_1111_1111_1111_1101;
原码：一个数的绝对值
反码：原码取反
补码：原码取反，再加1
例如：-3
-3原码：0b0000_0000_0000_0000_0000_0000_0000_0011;
-3反码：0b1111_1111_1111_1111_1111_1111_1111_1100;
-3补码：0b1111_1111_1111_1111_1111_1111_1111_1101;
```

##### 不同基本类型的按位运算

```java
boolean b1 = true;
boolean b2 = false;
//int b3 = b1 ^ b2; // 编译错误 b1 ^ b2的结果是boolean类型
System.out.println(b1 ^ b2);
//System.out.println(b1 ^ 2); // 编译错误 Operator '^' cannot be applied to 'boolean', 'int'
//System.out.println(~b1); // 编译错误 Operator '~' cannot be applied to 'boolean'
byte bt1 = 3;
byte bt2 = 2;
//byte bt3 = bt1 ^ bt2; // 编译错误 bt1 ^ bt2 的结果类型为int
int bt3 = bt1 ^ bt2;
System.out.println(bt1 ^ bt2); // 结果：1
System.out.println(3 ^ bt2); // 结果：1
byte bt4 = -3;
System.out.println(bt4 ^ bt2); // 结果：-1
System.out.println(-3 ^ bt2); // 结果：-1
```

1. 布尔类型的按位运算没有取反运算；布尔类型不能与其他类型进行按位运算。
2. byte、char等类型的按位运算，结果类型为int类型；先将byte、char等类型转换成int，再运算。
3. 与long类型进行按位运算，结果类型为long类型；先将byte、int 等类型转换成long，再运算。

##### 按位与（&）：

真值表：

| a    | b    | 结果 |
| ---- | ---- | ---- |
| 0    | 0    | 0    |
| 0    | 1    | 0    |
| 1    | 0    | 0    |
| 1    | 1    | 1    |

用途：

1. 复位；n & 0 = 0
2. 截取固定bit位 ；n & (m - 1)  = n的m低位表示
3. 奇偶判断；n & 1 = =1，则表示n 为基数；n & 1 == 0，则n为偶数。

##### 按位或（|）：

真值表：

| a    | b    | 结果 |
| ---- | ---- | ---- |
| 0    | 0    | 0    |
| 0    | 1    | 1    |
| 1    | 0    | 1    |
| 1    | 1    | 1    |

用途：

1. 设置bit位为1；n = n | 0b1111 ，则n的低4位 置为1。

##### 按位异或（^）：

真值表：

| a    | b    | 结果 |
| ---- | ---- | ---- |
| 0    | 0    | 0    |
| 0    | 1    | 1    |
| 1    | 0    | 1    |
| 1    | 1    | 0    |

性质：

1. 交换律；a  ^ b == b ^ a
2. 结合律；a ^ b ^ c == b ^ c ^ a
3. a ^ a = 0
4. a ^ 0 = a
5. a ^ -1 = ~a

用途：

1. 两个数交换a,b
   a ^= b;
   b ^= a;
   a ^= b;
2. 反转bit位
   n = 0b1010, n ^= 0b1111，则n的低四位被反转，n = 0b0101
3. 找不同
   n ^ m = x ，则x为1的bit位则表示n与m在此位置的bit位不相同。

##### 按位取反（～）：

真值表：

| a    | 结果 |
| ---- | ---- |
| 0    | 1    |
| 1    | 0    |

用途：

负数求绝对值；|n| = ~(n - 1)

##### 左移（<<）:

一个数的bit位向左移动n位，左边n位舍去，右边n位补0；

##### 有符号右移（>>）：

一个数的bit位向右移动n位，右边n位舍去，左边n位正数补0，负数补1；

##### 无符号右移动（>>>）：

一个数的bit位向右移动n位，右边n位舍去，左边n位补0；

###### **>>** 与  >>> 比较

```txt
00110111000111110110110101010101 正数

00001101110001111101101101010101 正数 >> 2

00001101110001111101101101010101 正数 >>> 2


10110111000111110110110101010101 负数

11101101110001111101101101010101 负数 >> 2

00101101110001111101101101010101 负数 >>> 2
```

有符号右移：位移n位后，空位补上符号位【正数补0，负数补1】

无符号右移：位移n位后，空位直接补0，不区分正负号



##### 练习题：

1. ###### 位运算求最值：

   ​	不得使用if-else或其他比较运算符

```java
public int maximum(int a, int b) {
        // 先考虑没有溢出时的情况，计算 b - a 的最高位，依照题目所给提示 k = 1 时 a > b，即 b - a 为负
         int k = b - a >>> 31;
         // 再考虑 a b 异号的情况，此时无脑选是正号的数字
         int aSign = a >>> 31, bSign = b >>> 31;
         // diff = 0 时同号，diff = 1 时异号
         int diff = aSign ^ bSign;
         // 在异号，即 diff = 1 时，使之前算出的 k 无效，只考虑两个数字的正负关系
         k = k & (diff ^ 1) | bSign & diff;
         return a * k + b * (k ^ 1);
    }
```

2. ###### 将数字变成 0 的操作次数

   给你一个非负整数 `num` ，请你返回将它变成 0 所需要的步数。 如果当前数字是偶数，你需要把它除以 2 ；否则，减去 1 。

   例如：18 ：

   ​		18 / 2 = 9

   ​		9 - 1 = 8

   ​		8 / 2 = 4

   ​		4 / 2 = 2

   ​		2 / 2 = 1

   ​		1 - 1 = 0

   ​		共6步。

   ```java
   // 1 的bit位数
   int bitCount = Integer.bitCount(num);
   // 总bit位数 - 1（从最高位1bit到最低位）
   int bitCount2 = 0;
   if(num != 0){
       if(num >> 16 != 0){bitCount2 += 16; num >>= 16;}
       if(num >> 8 !=0){bitCount2 += 8; num >>= 8;}
       if(num >> 4 !=0){bitCount2 += 4; num >>= 4;}
       if(num >> 2 !=0){bitCount2 += 2; num >>= 2;}
       if(num >> 1 !=0){bitCount2 += 1; num >>= 1;}
   }
   return bitCount + bitCount2;
   ```

   思路：一个bit位如果是1，则一定需要-1操作；非最低位，则需要右移操作。

   ​	所以总操作数 = 1 bit位数 + （该数值需要总bit位数 - 1）

   3. 2的幂

      给定一个整数，编写一个函数来判断它是否是 2 的幂次方。

      ```java
      public boolean isPowerOfTwo(int n) {
          if(n <= 0){
          	return false;
          }
          return (n ^ (n - 1)) == ((n - 1) << 1) + 1;
      }
      ```

3. 汉明距离

   两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。

   给出两个整数 x 和 y，计算它们之间的汉明距离。

   注意：
   0 ≤ x, y < 231.

   ```java
   // 方式1：
   public int hammingDistance(int x, int y) {
   	return Integer.bitCount(x ^ y);
   }
   
   // 方式2：
   public int hammingDistance(int x, int y) {
       int z = x ^ y;
       int count = 0;
       while(z != 0){
           count++;
           z &= z - 1;
       }
   	return count;
   }
   ```

4. 只出现一次的数：

   给定一个**非空**整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

   ```java
   public int singleNumber(int[] nums) {
       int m = 0;
       for(int i : nums){
       	m ^= i;
       }
       return m;
   }
   ```

5. 交换数位

   配对交换。编写程序，交换某个整数的奇数位和偶数位，尽量使用较少的指令（也就是说，位0与位1交换，位2与位3交换，以此类推）。

   例如：0b10 --> 0b01；0b11 --> 0b11; 0b101 --> 0b1010;

   ```java
   public int exchangeBits(int num) {
   	return ((num & 0x55555555) << 1) | ((num & 0xaaaaaaaa) >> 1);
   }
   ```

6. 一个数的补数

   补数就是一个数的二进制取反，但不包括该数的前导零位。

   例如：0b101 --> 0b10; 0b111 --> 0b0; 0b100 --> 0b11;

   ```java
   public int findComplement(int num) {
       int m = num;
       num |= num >> 1;
       num |= num >> 2;
       num |= num >> 4;
       num |= num >> 8;
       num |= num >> 16;
       return m ^ num;
   }
   ```

7. 给定两个整数 L 和 R ，找到闭区间 [L, R] 范围内，计算置位位数为质数的整数个数。

   （注意，计算置位代表二进制表示中1的个数。例如 21 的二进制表示 10101 有 3 个计算置位。还有，1 不是质数。）

   ```java
   // 方式1: 
   public int countPrimeSetBits(int L, int R) {
        int count = 0;
        boolean[] arr = new boolean[20];
        arr[2] = true;
        arr[3] = true;
        arr[5] = true;
        arr[7] = true;
        arr[11] = true;
        arr[13] = true;
        arr[17] = true;
        arr[19] = true;
        for (int i = L; i <= R; i++) {
            if(arr[Integer.bitCount(i)]){
                count++;
            }
        }
        return count;
    }
   
   // 方式2：
   public int countPrimeSetBits(int L, int R) {
        int count = 0;
        for (int i = L; i <= R; i++) {
            count += (665772 >> Integer.bitCount(i)) & 1;
        }
        return count;
    }
   ```

8. 消失的数字

   数组`nums`包含从`0`到`n`的所有整数，但其中缺了一个。请编写代码找出那个缺失的整数。你有办法在O(n)时间内完成吗？

   ```java
       public int missingNumber(int[] nums) {
           int result = 0;
           for (int i = 0; i < nums.length; i++) {
               result ^= nums[i] ^ i;
           }
           result ^= nums.length;
           return result;
       }
   ```

9. 颠倒二进制位

   例如：

   ```txt
   输入: 00000010100101000001111010011100
   输出: 00111001011110000010100101000000
   ```

   ```java
       public int reverseBits(int n) {
           n = (n >>> 16) | (n << 16);
           n = ((n & 0xff00ff00) >>> 8) | ((n & 0x00ff00ff) << 8);
           n = ((n & 0xf0f0f0f0) >>> 4) | ((n & 0x0f0f0f0f) << 4);
           n = ((n & 0xcccccccc) >>> 2) | ((n & 0x33333333) << 2);
           n = ((n & 0xaaaaaaaa) >>> 1) | ((n & 0x55555555) << 1);
           return n;
       }
   ```

10. 交替二进制数

    给定一个正整数，检查它的二进制表示是否总是 0、1 交替出现：换句话说，就是二进制表示中相邻两位的数字永不相同。

    ```java
        public boolean hasAlternatingBits(int n) {
            int m = n ^ (n >> 1);
            return (m & (m + 1)) == 0;
        }
    ```

11. 下一个数：

    下一个数。给定一个正整数，找出与其二进制表达式中1的个数相同且大小最接近的那两个数（一个略大，一个略小）。

    示例：

    ```
    输入：num = 2（或者0b10）
    输出：[4, 1] 或者（[0b100, 0b1]）
    ```

    ```java
        public int[] findClosedNumbers(int num) {
            int[] arr = new int[2];
            arr[0] = -1;
            arr[1] = -1;
            // mask二进制中的1标识了num的bit位的变化情况
            int mask = num ^ (num >>> 1);
            //说明num数值位全部为0或者1.不存在较大/较小值
            if(mask == 0){
                return arr;
            }
            // 获取mask低位1
            int mask1 = mask & -mask;
            // 复位最低位1
            int temp = mask & (mask - 1);
            // 获取mask次地位1
            int mask2 = temp & -temp;
            // mask1和mask2的二进制表示：0b1000000... n个0 即是2的幂
            if((mask1 & num) == mask1){// 表示num当前bit位为1 下一位是0 ‘01’形式来求较大值
                // 较大
                arr[0] = larger(num, mask1);
                // 较小
                if(mask2 != 0){// mask1处为较大，则mask2处为较小
                    arr[1] = smaller(num, mask2);
                }
            }else{// 表示num当前bit位为0 下一位是1 ‘10’形式来求较小值
                // 较小
                arr[1] = smaller(num, mask1);
                if(mask2 != 0){// mask1处为较小，则mask2处为较大
                    // 较大
                    arr[0] = larger(num, mask2);
                }
            }
            return arr;
        }
    
        public int smaller(int num , int mask){
            int smaller = -1;
            // 发生位置交换处之后的bit位数
            int maskBitCount = Integer.bitCount(mask -1);
            // 发生位置交换处之后的数
            int end = num & (mask -1);
            // 交换位置之后的位置复位 并 交换位置完成交换
            smaller = num ^ end ^ (mask + (mask << 1));
            
            int endBitCount = Integer.bitCount(end);
            // ((1 << endBitCount) - 1 为连续的1.
            // << (maskBitCount - endBitCount) 把连续的1放在最高位
            smaller |= (((1 << endBitCount) - 1) << (maskBitCount - endBitCount));
            return smaller;
        }
    
        public int larger(int num , int mask){
            int larger = -1;
            // 发生位置交换处之后的数
            int end = num & (mask -1);
            // 交换位置之后的位置复位 并 交换位置完成交换
            larger = num ^ end ^ (mask + (mask << 1));
            // 设置最小的末尾数
            larger |= ((1 << Integer.bitCount(end)) - 1);
            return larger;
        }
    ```

    思路：较小/较大的数：交换低位的相邻的10或01，并把交换位之后的1设置成最大或最小。

    例如：

    ```txt
    0b1001110000
        较小值：0b1001101000
        1. 交换0b1001110000 中的倒数第4，5位：0b1001101000
        2. 设置倒数第1，2，3位的值最大：0b1001101000
        
        较大值：0b1010000011
        1. 交换0b1001110000 中的倒数第7，8位：0b1010110000
        2.设置倒数第1，2，3，4，5，6位的值最小：0b1010000011
    --------------------------------------------------
    0b101101011
    	较小值：0b101100111
        1. 交换0b101101011 中的倒数第3,4位：0b101100111
        2. 设置倒数第1，2位的值最大：0b101100111
        
        较大值：0b101101101
        1. 交换0b101101011 中的倒数第2，3位：0b101101101
        2.设置倒数第1位的值最小：0b101101101
    ```

    