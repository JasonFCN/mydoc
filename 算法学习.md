#### 栈：Stack

栈与递归是紧密相连的。递归思想本质就是对子问题入栈，再依次出栈求解。

例子：二叉树的后序遍历问题

递归算法：

```java
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<Integer>();
        postorder(root, res);
        return res;
    }

    public void postorder(TreeNode root, List<Integer> res) {
        if (root == null) {
            return;
        }
        postorder(root.left, res);
        postorder(root.right, res);
        res.add(root.val);
    }
}
```

迭代算法：

```java
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<Integer>();
        if (root == null) {
            return res;
        }

        Deque<TreeNode> stack = new LinkedList<TreeNode>();
        TreeNode prev = null;
        while (root != null || !stack.isEmpty()) {
            while (root != null) {
                stack.push(root);
                root = root.left;
            }
            root = stack.pop();
            if (root.right == null || root.right == prev) {
                res.add(root.val);
                prev = root;
                root = null;
            } else {
                stack.push(root);
                root = root.right;
            }
        }
        return res;
    }
}
```

用迭代显式的实现递归思路：

1. 每拿到一个节 就把它保存在栈中
2. 继续对这个节点的 左子树 重复 过程1，直到左子树为 空
3. 因为保存在 栈 中的节点都遍历了 左子树 但是没有遍历 右子树，所以对栈中节点 出栈 并对它的 右子树 重复 过程1
4. 直到遍历完所有节点

单调栈：

#### 位运算：

与、或、取反、异或、左移、有符号右移、无符号右移

| 符号 | 名称       | 描述                                      |
| ---- | ---------- | ----------------------------------------- |
| &    | 与         | 两个bit位同为1，结果才为1                 |
| \|   | 或         | 只要存在一个bit位为1，结果就为1           |
| ~    | 取反       | 0变成1，1变成0                            |
| ^    | 异或       | bit位相同，结果为0；bit不同，结果为1      |
| <<   | 左移       | bit向左移动若干位，高位舍弃，低位补0      |
| >>   | 有符号右移 | bit向右移动若干位，低位舍弃，高位补符号位 |
| >>>  | 无符号右移 | bit向右移动若干位，低位舍弃，高位补0      |

##### java基本类型的二进制存储

```txt
以int类型为例：
    int a1 = 3;
    int b2 = 0b0000_0000_0000_0000_0000_0000_0000_0011;
    int b1 = -1;
    int b2 = 0b1111_1111_1111_1111_1111_1111_1111_1111;
    int c1 = -3;
    int c2 = 0b1111_1111_1111_1111_1111_1111_1111_1101;
原码：一个数的绝对值
反码：原码取反
补码：原码取反，再加1
例如：-3
-3原码：0b0000_0000_0000_0000_0000_0000_0000_0011;
-3反码：0b1111_1111_1111_1111_1111_1111_1111_1100;
-3补码：0b1111_1111_1111_1111_1111_1111_1111_1101;
```

##### 不同基本类型的按位运算

```java
boolean b1 = true;
boolean b2 = false;
//int b3 = b1 ^ b2; // 编译错误 b1 ^ b2的结果是boolean类型
System.out.println(b1 ^ b2);
//System.out.println(b1 ^ 2); // 编译错误 Operator '^' cannot be applied to 'boolean', 'int'
//System.out.println(~b1); // 编译错误 Operator '~' cannot be applied to 'boolean'
byte bt1 = 3;
byte bt2 = 2;
//byte bt3 = bt1 ^ bt2; // 编译错误 bt1 ^ bt2 的结果类型为int
int bt3 = bt1 ^ bt2;
System.out.println(bt1 ^ bt2); // 结果：1
System.out.println(3 ^ bt2); // 结果：1
byte bt4 = -3;
System.out.println(bt4 ^ bt2); // 结果：-1
System.out.println(-3 ^ bt2); // 结果：-1
```

1. 布尔类型的按位运算没有取反运算；布尔类型不能与其他类型进行按位运算。
2. byte、char等类型的按位运算，结果类型为int类型；先将byte、char等类型转换成int，再运算。
3. 与long类型进行按位运算，结果类型为long类型；先将byte、int 等类型转换成long，再运算。

##### &：

性质：只有全为1，结果才为1

用途：0 & n = 0

有符号右移 **>>** 与 无符号右移 **>>>**

```txt
00110111000111110110110101010101 正数

00001101110001111101101101010101 正数 >> 2

00001101110001111101101101010101 正数 >>> 2


10110111000111110110110101010101 负数

11101101110001111101101101010101 负数 >> 2

00101101110001111101101101010101 负数 >>> 2
```

有符号右移：位移n位后，空位补上符号位【正数补0，负数补1】

无符号右移：位移n位后，空位直接补0，不区分正负号

位运算求最值：

```java
public int maximum(int a, int b) {
        // 先考虑没有溢出时的情况，计算 b - a 的最高位，依照题目所给提示 k = 1 时 a > b，即 b - a 为负
         int k = b - a >>> 31;
         // 再考虑 a b 异号的情况，此时无脑选是正号的数字
         int aSign = a >>> 31, bSign = b >>> 31;
         // diff = 0 时同号，diff = 1 时异号
         int diff = aSign ^ bSign;
         // 在异号，即 diff = 1 时，使之前算出的 k 无效，只考虑两个数字的正负关系
         k = k & (diff ^ 1) | bSign & diff;
         return a * k + b * (k ^ 1);
    }
```

