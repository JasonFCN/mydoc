#### 一：Java并发机制的底层实现原理

##### volatile的应用

volatile的定义：Java编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致地更新，线程应该确保通过排他锁单独获得这个变量。

volatile的实现：在X86处理器下，对volatile变量的操作会生成一条`lock addl $0x0,(%esp)`的汇编指令。

`lock`指令的作用：

1）将当前处理器缓存行的数据写回到系统内存。

2）这个写回内存的操作会使其他CPU里缓存了该内存地址的数据无效。

volatile优化：

追加字节填充缓存行。有些CPU缓存行为64字节。该操作在java7中及后续版本不能工作，会被JVM即时编译器优化掉。在Java8可以使用注解`sun.misc.Contended`来修饰类或字段。

```java
package com.cwj;

import org.openjdk.jol.info.ClassLayout;
import sun.misc.Contended;

/**
 * @author: Chenwujie
 * @date: 2021-03-29 10:17
 * VM options: -XX:-RestrictContended 
 */
public class CacheLineTest {
    public static void main(String[] args) {
        CacheLineValue cacheLineValue = new CacheLineValue();
        System.out.println(ClassLayout.parseInstance(cacheLineValue).toPrintable());
    }

    @Contended
    public static class CacheLineValue{
        private volatile int value;
    }
}

```

运行结果：

```console
com.cwj.CacheLineTest$CacheLineValue object internals:
 OFFSET  SIZE   TYPE DESCRIPTION                               VALUE
      0     4        (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)
      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)
      8     4        (object header)                           43 c1 00 f8 (01000011 11000001 00000000 11111000) (-134168253)
     12   128        (alignment/padding gap)                  
    140     4    int CacheLineValue.value                      0
    144   128        (loss due to the next object alignment)
Instance size: 272 bytes
Space losses: 128 bytes internal + 128 bytes external = 256 bytes total


Process finished with exit code 0

```

##### synchronized的实现原理与应用

synchronized是个重量级锁，但是随着版本优化，引入了偏向锁，轻量级锁，以及锁的存储结构和升级过程。

synchronized实现同步的基础：Java中的每一个对象都可以作为锁。表现形式有：

- 对于普通同步方法，锁是当前对象。
- 对于静态同步方法，锁是当前类的Class对象。
- 对于同步代码块，锁是synchronized括号里的对象。

同步代码块实现原理是利用`monitorenter`和`monitroexit`指令来实现的；同步方法是使用`ACC_SYNCHRONIZED`标识来实现，其底层还是会使用到`monitorenter`和`monitroexit`指令。

**Java 对象头：**

对象头是Java对象内存布局中的一部分，在64位虚拟机下，对象头的Mark Word是64bit的大小：

<img src="%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/hotspotMarkWord.png" alt="hotspotMarkWord"  />

​		为了减少获得锁和释放锁带来的性能消耗，引入了偏向锁和轻量级锁，锁一共有4种状态，无锁状态，偏向锁状态，轻量级锁状态，重量级锁状态。这几种锁状态随着竞争情况逐渐升级。锁可以升级，但不能降级。

锁状态转换过程：

![synchronizedLock](%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/synchronizedLock.jpg)

##### 原子操作的实现原理

处理器实现原子操作的方式：

1）使用总线锁：当一个处理器在总线上输出`Lock # `信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占共享内存。

2）使用缓存锁：锁定总线会导致修改其他缓存地址的请求也会被锁定，开销大。故使用缓存锁定方式解决：内存区域如果被缓存在处理器的缓存行中，并且在Lock操作期间被锁定，那么当它执行锁操作回写到内存时，处理器不在总线上声言`Lock #`信号，而是修改内部的内存地址，并允许他的缓存一致性机制来保证操作的原子性，因为缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据，当其他处理器回写已被锁定的缓存行的数据时，会使缓存行无效。

Java实现的原子操作：

通过锁和循环CAS来实现。

循环CAS是利用处理器提供的CMPXCHG指令实现。

CAS实现原子操作的三大问题：

1）ABA问题

​		CAS操作是通过比较预期值的方式来进行，所以如果一个值从A变成B，又变回了A。那么在CAS中就判定为没有变化，操作成功。解决该问题的思路就是使用版本号。JDK提供了`AtomicStampedReference`类来解决。

2）循环时间开销大

如果自旋长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令，那么效率会有一定的提升。

3）只能保证一个共享变量的原子操作

CAS不支持多个变量的原子操作。可以使用锁来解决。还有一种巧妙地方式是：把变量合成一个变量的方式进行CAS操作。

#### 二：Java内存模型

##### Java内存模型基础

并发编程模型的两个关键问题：

线程之间如何通信及线程之间如何同步。

​		通信是指线程之间以何种机制来交换信息。在命令式编程中，线程之间的通信机制有两种：共享内存和消息传递。在共享内存的并发模型中，线程之间共享程序的公共状态，通过写-读内存中的公共状态进行隐式通信。在消息传递的并发模型里，通过发送消息来显式进行通信。

​		同步是指线程中用于控制不同线程间操作发生相对顺序的机制。在共享内存并发模型里，同步是显式进行的。程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行。在消息传递的并发模型里，由于消息的发送必须在消息的接收之前，因此同步是隐式的。

Java采用的共享内存并发模型。Java线程之间的通信是隐式进行的。

Java线程之间的通信由Java内存模型（简称：JMM）控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见。

![JMM](%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/JMM.png)

​		JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存，本地内存中存储了该线程以读/写共享变量的副本。

**重排序：**

为了提高程序的执行效率，编译器和处理器常常会对指令做重排序。重排序分3种类型。

1）编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。

2）指令级并行的重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。

3）内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。

Java源码所经历的重排序：

源码--》1：编译器优化重排序--》2：指令级并行重排序--》3：内存系统重排序--》最终执行的指令序列

1属于编译器优化的重排序，2、3属于处理器重排序。编译器重排序规则会禁止特定类型的编译器重排序。对于处理器重排序规则会要求在Java编译器生成指令序列时，插入特定类型的内存屏障指令，通过内存屏障指令来禁止特定类型的处理器重排序。

JMM属于语言级的内存模型，它确保在不同的平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。

**并发编程模型的分类**

​		现代的处理器使用写换成去临时保存向内存写入的数据。写缓冲区可以保证指令流水线持续运行，它可以避免由于处理器停顿下来等待向内存写入数据而产生的延迟。同时通过以批处理的方式刷新写缓冲区，以及合并写缓冲区中对同一内存地址的多次写，减少对内存总线的占用。虽然写缓冲区有那么多好处，但每个处理器上的写缓冲区，仅仅对它所在的处理器可见。这个特性会对内存操作的执行顺序产生重要的影响：处理器对内存的读/写操作的执行顺序，不一定与内存实际发生的读/写操作顺序一致！

x86处理器只允许写后读（Store-Load）的重排序。

​		为了保证内存可见性，Java编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。其中有一个`StoreLoad Barries`屏障，可以禁止Store-Load重排序，但是该操作开销会很昂贵，因为当前处理器通常要把写缓冲区中的数据全部刷新到内存中。

**happens-before简介**

​		从JDK5开始，使用JSR-133内存模型。使用happens-before的概念来阐述操作之间的内存可见性。在JMM中如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系。这里的两个操作既可以是一个线程之内，也可以是在不同线程之间。

常见的规则如下：

- 程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。
- 监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。
- valatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。
- 传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。

-------

​		两个操作之间具有happens-before关系，并不意味着前一个操作必须要在后一个操作之前执行！happens-before仅仅要求前一个操作对后一个操作可见，且前一个操作按顺序排在第二个操作之前。

------------------

##### 重排序

​		数据依赖性：如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间存在数据依赖性。数据依赖类型如下：

读后写|写后读|写后写

只要重排序上述3种类型的两个操作的执行顺序，程序的执行结果就会被改变。

这里的依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。

**as-if-serial语义**

as-fi-serial语义的意思是：不管怎么重排序，程序的执行结果不能被改变。

在单线程程序中，对存在控制以来的操作重排序，不会改变执行结果；但在多线程程序中，对存在控制以来的操作重排序，可能会改变程序的执行结果。

##### 顺序一致性

顺序一致性内存模型是一个理论参考模型，在设计的时候，处理器的内存模型和变成语言的内存模型都会以顺序执行内存模型作为参考。

**数据竞争与顺序一致性**

当程序未正确同步时，就可能会存在数据竞争。java内存模型规范对数据竞争的定义：

在一个线程中写变量，在另一个变成读同一个变量，而且写和读没有通过同步来排序。

**顺序一致性内存模型**

顺序一致性内存模型有两大特性：

1）一个线程中的所有操作必须按照程序的顺序来执行。

2）所有线程都只能看到一个单一的操作执行顺序。在顺序一致性内存模型中，每个操作都必须原子执行且立刻对所有线程可见。

​		该模型等同于把所有线程的操作串行执行。在JMM中，临界区中的代码可以重排序（但JMM不顺序临界区内的代码逃逸到临界区之外，那样会破坏监视器的语义）。JMM会在退出临界区和进入临界区的时间点做一些特殊处理，使得线程在这两个时间点具有与顺序一致性模型相同的内存视图。

**未同步程序的执行特性：**

​		对未同步或未正确同步的多线程程序，JMM只提供最小安全性：线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值（0，Null， False），JMM保证线程读操作读取到的值不会是毫不相关的值。实现方式是在分配对象时，首先会对内存空间进行初始化。

##### volatile的内存语义

volatile的特性：

- 可见性。对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。
- 原子性。对任意单个volatile变量的读/写具有原子性，但类似于volatile++这种复合操作不具有原子性。

happens-before关系：

对于程序员来说，volatile的可见性实现了线程之间的通信。volatile写 happens-before 于volatile读。

内存语义：

- 当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存。
- 当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。

内存语义的实现：

​		对于重排序，分为编译器重排序和处理器重排序。为了实现volatile的内存语义，需要分别限制这两种重排序。JMM对编译器制定的volatile重排序规则表。

| 是否能重排序 | 第二个操作 | 第二个操作 | 第二个操作 |
| ------------ | ---------- | ---------- | ---------- |
| 第一个操作   | 普通读/写  | volatile读 | volatile写 |
| 普通读/写    |            |            | NO         |
| volatile读   | NO         | NO         | NO         |
| volatile写   |            | NO         | NO         |

从表中可以得出：

- 当第二个操作是volatile写时，不管第一个操作是什么，都不能重排序。这个规则确保volatile写之前的操作不会被编译器重排序到volatile写之后。
- 当第一个操作是volatile读时，不管第二个操作是什么，都不能重排序。这个规则确保volatile读之后的操作不会被编译器重排序到volatile读之前。
- 当第一个操作是volatile写时，第二个操作是volatile读时，不能重排序。

为了实现上述规则，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。下面是基于保守策略的JMM内存屏障插入策略。

- 在每个volatile写操作的前面插入一个`StoreStore`屏障。
- 在每个volatile写操作的后面插入一个`StoreLoad`屏障。
- 在每个volatile读操作的前面插入一个`LoadLoad`屏障。
- 在每个volatile读操作的前面插入一个`LoadStore`屏障。

​		如此保守的策略保证了volatile一致的内存语义。但在实际情况中，编译器可以根据具体情况省略不必要的屏障，以x86处理器为例，处理器的重排序策略中，只允许写-读可以重排序，其他不允许重排序。因此，可以只保留最后的`StoreLoad`屏障即可。因此也意味着在x86架构中，volatile写比volatile读的开销大。

##### 锁的内存语义

锁可以让临界区互斥执行。

**锁的释放-获取所建立的happens-before关系**

锁的释放happens-before于该锁的获取。

**锁的释放-获取的内存语义**

JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。

**锁内存语义的实现**

- 公平锁和非公平锁释放时，最后倒要写一个volatile变量state。
- 公平锁获取时，首先会去读volatile变量。
- 非公平锁获取时，首先会用CAS更新volatile变量，这个操作同时具有volatile读和volatile写的内存语义。

对于CAS操作的底层实现，x86处理器中是基于一个Lock前缀的cmpxchg指令。lock前缀的说明如下：

- 确保对内存的读-改-写操作原子执行。
- 禁止该指令，与之前和之后的读和写指令重排序。
- 把写缓存区中的所有数据刷新到内存中。

**juc包的实现**

Java的CAS会使用现代处理器上提供的高效机器级别的原子指令，这些原子指令以原子方式对内存执行读-改-写操作，这是在多处理器中实现同步的关键。同时，volatile变量的读/写和CAS可以实现线程之间的通信。这两个特性形成了Java并发包的基石。

<img src="%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/juc_frame.png" alt="juc_frame" style="zoom:150%;" />

##### final域的内存语义

与之前的锁和volatile相比，对final域的读和写更像是普通变量的访问。

**final域的重排序规则**

对于final域，编译器和处理器要遵守两个重排序规则。

- 在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作不能重排序。
- 初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序。

**final域的内存语义的实现**

对于final域的写操作，编译器会在final域的写操作之后，构造函数return之前，插入一个`StoreStore`屏障。

对于final域的读操作，编译器会在final域的读操作之前，插入一个`LoadLoad`屏障。

**含有final域的对象引用不能从构造函数内"逸出"**

​		前面所说的final域的重排序规则可以确保：在引用变量为任意线程可见之前，该引用变量指向的对象的final域已经在构造函数中被正确初始化过了。其实，要得到这个效果，还需要保证：***在构造函数内部，不能让这个构造对象的引用为其他线程可见，也就是对象引用不能在构造函数中“逸出”***。

```java
import java.util.concurrent.TimeUnit;

/**
 * @author: Chenwujie
 * @date: 2021-03-30 16:04
 */
public class FinalTest {
    private final int value;
    public static FinalTest obj;

    public FinalTest(int value) {
        obj = this;
        try {
            TimeUnit.MILLISECONDS.sleep(200);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        this.value = value;
    }

    public static void main(String[] args) {
        Thread thread = new Thread(new Runnable() {
            @Override
            public void run() {
                if (FinalTest.obj != null) {
                    System.out.println(obj.value);
                }
            }
        });
        thread.start();
        FinalTest finalTest = new FinalTest(1);
        System.out.println("end");
    }
}
```

**final语义在处理器中的实现**

​		在前面提到，final的写操作会插入`StoreStore`屏障，读操作会插入`LoadLoad`屏障。由于X86处理器不会对写-写操作、读-读操作做重排序，所以final的语义实现不会插入任何屏障！

##### happens-before

JMM设计中，需要考虑两个方面：

1）有利于开发者的使用，要易于理解、使用。

2）编译器和处理器的实现，束缚要尽可能地少，有利于进一步的优化来提高性能。

**happens-before的定义**

1）如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之间。

2）两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么这种重排序并不非法。

上面的1）是JMM对程序员的承诺。它保证了可见性关系。

上面的2）是JMM对编译器和处理器重排序的约束原则。只要不改变程序的执行结果，怎么优化、重排序都行。对于程序员来说，这样的优化并不影响程序的执行结果，不用关心真实的执行顺序。因此，happens-before关系本质上和as-fi-serial语义是一回事。

- as-if-serial语义保证单线程内程序的执行结果不被改变，happens-before关系保证正确同步的线程程序的执行结果不被改变。
- as-fi-serial语义给编写单线程程序的程序员创造了一个幻境：单线程程序的按程序的顺序来执行的。happens-before关系给编写正确同步的多线程程序的程序员创造了一个幻境：正确同步的多线程程序是按happens-before指定的顺序来执行的。

happens-before规则：

- 程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。
- 监视器锁规则：对一个锁的释放，happens-before于随后对这个锁的获取。
- volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。
- 传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。
- start()规则：如果线程A执行操作ThreadB.start()（启动线程），那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作。
- join()规则：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join操作成功返回。

##### 双重检测锁定与延迟初始化

在Java中，我们可能需要延迟一些高开销的对象初始化操作，并且只有在使用这些对象的时候才进行初始化。如下面的代码：

```java
package com.cwj;

/**
 * @author: Chenwujie
 * @date: 2021-03-30 17:02
 */
public class DoubleCheckTest {
    private static Instance obj;

    public static Instance getInstance(){
        if(obj == null){
            obj = new Instance();
        }
        return obj;
    }

    private static class Instance{

    }
}

```

如果这个程序在单线程中运行，没有太大问题，但是在多线程中就很容易出现问题。所以可以对方法做同步处理来实现线程安全：

```java
package com.cwj;

/**
 * @author: Chenwujie
 * @date: 2021-03-30 17:02
 */
public class DoubleCheckTest {
    private static Instance obj;

    public synchronized static Instance getInstance(){
        if(obj == null){
            obj = new Instance();
        }
        return obj;
    }

    private static class Instance{

    }
}

```

​		由于某个线程执行该方法时，其他线程都要阻塞，所以性能开销大。所以就有了双重检测：在进入同步代码块之前先判断条件，进入后再判断一次，来减少锁的开销。

```java
package com.cwj;

/**
 * @author: Chenwujie
 * @date: 2021-03-30 17:02
 */
public class DoubleCheckTest {
    private static Instance obj;

    public static Instance getInstance(){
        if(obj == null){
            synchronized (DoubleCheckTest.class){
                if(obj == null){
                    obj = new Instance();
                }
            }
        }
        return obj;
    }

    private static class Instance{

    }
}

```

即使这样的优化方案，还是存在一个问题：在对象创建并赋值引用地址过程中，会被JIT编译器重排序。

如何禁止这种重排序？有两种方案：

1）使用valatile

只需要把`obj`声明为volatile即可。

2）使用类初始化方案

JVM在类的初始化阶段，会执行类的初始化。在执行初始化阶段，会获得一个锁。这个锁可以同步多个线程对同一个类的初始化。

```java
package com.cwj;

/**
 * @author: Chenwujie
 * @date: 2021-03-30 17:02
 */
public class DoubleCheckTest {
    private static class InstanceHolder{
        public static Instance instance = new Instance();
    }
    public static Instance getInstance(){
        return InstanceHolder.instance;
    }

    private static class Instance{

    }
}

```

类的初始化方案更简洁，但volatile方案也有其他优势：它可以实现对实例字段的初始化。

#### 三：Java并发编程基础

##### 线程简介：

**什么是线程？**

​		现代操作系统在运行一个程序时，会为其创建一个进程。例如启动一个Java程序。现代操作系统调度的最小单元是线程，也叫轻量级进程。在一个进程里可以创建多个线程，这些线程都拥有各自的计数器、堆栈、和局部变量等属性，并且能够访问共享的内存变量。处理器在这些线程上高速切换，让使用者感觉到这些线程在同时进行。

**为什么要使用线程？**

1）使用更多的处理器核心

2）更快的响应

3）更好的变成模型

**线程优先级**

​		现代操作系统基本采用分时的形式调度运行的线程，操作系统会分出一个个时间片，线程会分配到若干时间片，当线程的时间片用完了就会发生线程调度，并等待着下次分配。线程分配到的时间片多少也就决定了线程使用处理器资源的多少，而线程优先级就是决定线程需要多或者少分配一些处理器资源的线程属性。

​		在Java中，优先级被设置成了10个优先等级1-10。默认为5。但各个操作系统对线程的优先级又有不同的划分范围，所以Java的线程优先等级与系统的等级不一一对应。而且Java线程的优先级的实现需要系统的支持，所以，*对Java线程设置优先级并不能保证带来优先级的差异。*

**线程状态**

Java线程在运行的生命周期中可能处于不同的状态（6种）：

| 状态         | 说明                                                         |
| ------------ | ------------------------------------------------------------ |
| NEW          | 初始状态，线程被构建，但是还没有调用start()方法              |
| RUNABLE      | 运行状态，Java线程将操作系统中的就绪和运行两种状态笼统地称作“运行中” |
| BLOCKED      | 阻塞状态，表示线程阻塞于锁                                   |
| WAITING      | 等待状态，表示线程进入等待，进入该状态标识当前线程需要等待其他线程做出一些特定动作（通知或中断） |
| TIME_WAITING | 超时等待状态，该状态不同于WAITING，它是可以在指定的时间自行返回的 |
| TERMINATED   | 终止状态，表示当前线程已经执行完毕                           |

![threadState](%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/threadState.png)

> 注意：Lock接口的获得锁的操作会使线程进入WAITING状态，因为阻塞的实现是用到了LockSupport类相关的方法。

**Daemon线程**

​		守护线程是一种支持型线程，因为它主要被用作程序中后台调度以及支持性工作，当虚拟机中不存在非Daemon线程的话，Java虚拟机将会退出。

> 设置线程以守护模式运行，需要在启动前设置。
>
> 在构建Daemon线程时，不能依靠finally块中的内存来确保执行关闭或清理资源的逻辑。

##### 线程的启动与终止：

**线程的创建**

创建一个线程并不像创建一个普通对象一样简单，还需要进行一些初始化工作。

```java
    private void init(ThreadGroup g, Runnable target, String name,
                      long stackSize, AccessControlContext acc,
                      boolean inheritThreadLocals) {
        if (name == null) {
            throw new NullPointerException("name cannot be null");
        }

        this.name = name;

        Thread parent = currentThread();
        SecurityManager security = System.getSecurityManager();
        if (g == null) {
            /* Determine if it's an applet or not */

            /* If there is a security manager, ask the security manager
               what to do. */
            if (security != null) {
                g = security.getThreadGroup();
            }

            /* If the security doesn't have a strong opinion of the matter
               use the parent thread group. */
            if (g == null) {
                g = parent.getThreadGroup();
            }
        }

        /* checkAccess regardless of whether or not threadgroup is
           explicitly passed in. */
        g.checkAccess();

        /*
         * Do we have the required permissions?
         */
        if (security != null) {
            if (isCCLOverridden(getClass())) {
                security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);
            }
        }

        g.addUnstarted();

        this.group = g;
        this.daemon = parent.isDaemon();
        this.priority = parent.getPriority();
        if (security == null || isCCLOverridden(parent.getClass()))
            this.contextClassLoader = parent.getContextClassLoader();
        else
            this.contextClassLoader = parent.contextClassLoader;
        this.inheritedAccessControlContext =
                acc != null ? acc : AccessController.getContext();
        this.target = target;
        setPriority(priority);
        if (inheritThreadLocals && parent.inheritableThreadLocals != null)
            this.inheritableThreadLocals =
                ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);
        /* Stash the specified stack size in case the VM cares */
        this.stackSize = stackSize;

        /* Set thread ID */
        tid = nextThreadID();
    }
```

**线程启动**

启动一个线程只需要调用`start()`方法即可。

**线程中断**

​		中断可以理解为线程的一个标识位属性，它表示一个运行中的线程是否被其他线程进行了中断操作。一个线程可以调用另一个线程对象的`interrupt()`方法来对该线程进行中断。

​		线程通过检查自身是否被中断来进行响应，线程通过`isInterrupted()`来进行判断是否被中断，也可以调用静态方法`Thread.interrupted()`对当前线程的中断标识位进行复位。如果该线程已经处于终结状态，即使该线程被中断过，在调用该线程对象的`isInterrupted()`也会返回false。

​		在Java的API中，许多生命抛出`InterruptedException`的方法，在抛出该异常之前，Java虚拟机会先将该线程的中断标识位清除，再抛出异常，此时再调用`isInterrupted()`将返回false。

**安全地终止线程**

上面提到的中断操作可以实现对线程的终止操作，当然也可以通过一个外部的布尔变量来控制程序的运行和停止。

##### 线程间通信：

**volatile和synchronized关键字**

volatile实现了对共享变量可见性。

​		synchronized的实现通过监视器来完成。当对一个程序进入一个同步块之前要获取锁，当退出时，要释放锁，并把更新的值刷新回主内存。

**等待/通知机制**

每个对象都有`wait()`和`notify()`方法，因为这两个方法都是属于Object类。但是它依赖监视器。

**管道输入/输出流**

**Thread.join()的使用**

如果一个线程A执行了`thread.join()`语句，则表示：当前线程A等待线程thread终止之后才从`thread.join()`返回。

**ThreadLocal的使用**

ThreadLocal实现了变量的线程隔离。它是以ThreadLocal对象为key，以任意对象为value的存储结构，这个数据被当前线程所持有。

#### 四：Java锁

##### Lock接口

​        锁是用来控制多个线程访问共享资源的方式，一般来说，一个锁能够防止多个线程同时访问共享资源（但有些锁可以允许多个线程并发的访问共享资源，比如读写锁）。在Lock接口出现之前，Java程序是靠synchronized关键字来实现的。而Lock也提供了类似的锁功能，只是需要显式地获取和释放锁。虽然它缺少了像synchronized的便捷性，但是也提供了可操作性、可中断的获取锁，以及超时获取锁等功能。

Lock的简单使用：

```java
package com.cwj.juc;

import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * @author: Chenwujie
 * @date: 2021-04-06 08:51
 */
public class LockTest {
    public static void main(String[] args) {
        Lock lock = new ReentrantLock();
        // 在try代码块之外获取锁,因为如果放在try代码块内获取锁失败，会导致锁被无故释放。
        lock.lock();
        try {
            // 业务
        }finally {
            lock.unlock();
        }
    }
}

```

Lock提供的接口：

| 方法名称                                                     | 描述                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| `void lock()`                                                | 获取锁。如果该锁不可用，则出于线程调度目的，当前线程将被禁用，并处于休眠状态，直到获得该锁为止。 |
| `void lockInterruptibly() throws InterruptedException`       | 除非当前线程被中断，否则获取锁。<br>获取锁（如果有）并立即返回。<br/>如果该锁不可用，则出于线程调度目的，当前线程将被禁用，并在发生以下两种情况之一之前处于休眠状态：<br/>- 该锁是由当前线程获取的； <br/>- 其他一些线程会中断当前线程，并支持中断获取锁。 |
| `boolean tryLock()`                                          | 尝试获取锁（如果有），并立即返回true值。 如果锁不可用，则此方法将立即返回false值。 |
| `boolean tryLock(long time, TimeUnit unit) throws InterruptedException` | 超时地获取锁，当前线程在以下3种情况下会返回：<br/>- 当前线程在指定时间内获得锁；<br/>- 当前线程在超时时间内被中断；<br/>- 超时，返回true。 |
| `void unlock()`                                              | 释放锁                                                       |
| `Condition newCondition()`                                   | 获取等待通知组件，该组件和当前的锁绑定，当前线程只有获得了锁，才能调用该组件的`await()`方法，而调用后，当前线程将释放锁。 |

##### 队列同步器

​		队列同步器`AbstractQueuedSynchronizer`（以下简称同步器），是用来构建锁或者其他同步组件的基础框架，它使用了一个 int 成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作，它是实现大部分同步需求的基础。
​		同步器的主要使用方式是继承，子类通过继承同步器并实现它的抽象方法来管理同步状态，在抽象方法的实现过程中免不了要对同步状态进行更改，这时就需要使用同步器提供的3个方法（`getState()`、`setState(int newState)`和`compareAndSetState(int expect, int update)`）来操作。因为它们能够保证状态的修改是安全的。子类推荐被定义为自定义同步组件的静态内部类，同步器自身没有实现任何同步方法接口，它仅仅是定义了若干同步状态获取和释放的方法来供自定义同步组件使用，同步器既可以支持独占式地获取同步状态，也可以支持共享式地获取同步状态，这样就可以方便实现不同类型的同步组件（`ReentrantLock`、`ReentrantReadWriteLock`和`CountDownLock`等）。

​		同步器是实现锁（也可以是任意同步组件）的关键，在锁的实现中聚合同步器，利用同步器实现锁的予以。可以这样理解二者之间的关系：锁是面向使用者的，它定义了使用者与锁交互的接口，隐藏了实现细节；同步器面向的是锁的是闲着，它简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。锁和同步器很好地隔离了使用者和实现者所需关注的领域。

使用方式：

同步器的设计是基于模板方法模式的，也就是说，使用者需要继承同步器并重写指定的方法，随后将同步器组合在自定义同步组件的实现中，并调用同步器提供的模板方法，而这些模板方法将会调用使用者重写的方法。

重写同步器指定的下列方法时，需要使用`getState()`、`setState(int newState)`、和/或`compareAndSetState(int, int)`方法来检查和/或修改同步状态：

| 方法名称                                  | 描述                                                         |
| ----------------------------------------- | ------------------------------------------------------------ |
| `protected boolean tryAcquire(int)`       | 独占式获取同步状态，实现该方法需要查询当前状态并判断同步状态是否符合预期，然后再进行CAS设置同步状态 |
| `protected boolean tryRelease(int)`       | 独占式释放同步状态，等待获取同步状态的线程将有机会获取同步状态 |
| `protected int tryAcquireShared(int)`     | 共享式获取同步状态，返回大于等于0的值，表示获取成功，反之，获取失败 |
| `protected boolean tryReleaseShared(int)` | 共享式释放同步状态                                           |
| `protected boolean isHeldExclusively()`   | 当前同步器是否在独占模式被线程占用，一般该方法表示是否被当前线程所独占 |

通过调用同步器提供的模板方法，来实现对重写的方法的调用，完成同步操作：

| 方法名称                                   | 描述                                                         |
| ------------------------------------------ | ------------------------------------------------------------ |
| `void acquire(int)`                        | 独占式获取同步状态，如果当前线程获取同步状态成功，则由该方法返回，否则，将会进入同步队列等待，该方法将会调用重写的`tryacquire(int)`方法 |
| `void acquireInterruptibly(int)`           | 与`acquire(int)`方法相同，但是该方法响应中断，当前线程未获取到同步状态而进入同步队列中，如果当前线程被中断，则该方法会抛出InterruptedException并返回 |
| `boolean tryAcquireNanos(int, long)`       | 在`acquireInterruptibly(int)`基础上增加了超时限制，如果当前线程在超市时间内没有获取到同步状态，那么将会返回false，如果获取到了返回true |
| `void acquireShared(int)`                  | 共享式获取同步状态，如果当前线程未获取到同步状态，将会进入同步队列等待，与独占式获取的主要区别是在同一时刻可以有多个线程获取到同步状态 |
| `void acquireSharedInterruptibly(int)`     | 与`void acquireShared(int)`相同，可以响应中断                |
| `boolean tryAcquireSharedNanos(int, long)` | 与`void acquireSharedInterruptibly(int)`相同，增加了超时限制 |
| `boolean release(int)`                     | 独占式的释放同步状态，该方法会在释放同步状态之后，将同步队列中第一个节点包含的线程唤醒 |
| `boolean releaseShared(int)`               | 共享式地释放同步状态                                         |
| `Collection<Thread> getQueuedThreads()`    | 获取等待在同步队列上的线程集合                               |

​		同步器提供的模板方法大致分为三种：独占式获取与释放同步状态、共享式获取与释放同步状态、查询同步队列中的等待线程情况。队列同步器的实现：
同步器依赖内部的同步队列（FIFO的队列）来完成同步状态的管理，当前线程获取同步状态失败时，同步器会将当前线程以及等待状态等信息构造成为一个节点（Node）并将其加入同步队列，同时会阻塞当前线程，当同步状态释放时，会把首节点中的线程唤醒，使其再次尝试获取同步状态。
节点的属性及描述：

| 属性              | 描述                                                         |
| ----------------- | ------------------------------------------------------------ |
| `int waitStatus`  | 等待状态，仅包含下列值：<br/>CANCELLED: 值为1，表示该节点由于超时或中断而被取消。该状态也不会再被改变。同时拥有该状态节点的线程永远不会再次阻塞。<br/>SIGNAL: 值为-1，表示需要信号通知。该节点的后继节点是（或者将要）阻塞的（通过调用park方法），所以当该节点的线程释放锁或者取消时，当前节点必须唤醒它的后继节点。为了避免冲突，`acquire`方法必须首先提示它们需要一个信号，然后重试原子获取，失败时阻塞。<br/>CONDITION: 值为-2，表示目前该节点在一个条件队列里。该值不会用于同步队列中的节点。当该节点进入同步队列时，该节点状态值会设置为0。<br/>PROPAGATE: 值为-3，表示下一次共享式同步状态获取将会无条件地被传播下去。<br/>0: 初始状态。 |
| `Node prev`       | 前驱节点，当节点加入同步队列时被设置（尾部添加）             |
| `Node next`       | 后继节点                                                     |
| `Node nextWaiter` | 等待队列中的后继节点。如果当前节点是共享的，那么这个字段将是一个SHARED常量，也就是说节点的不同类型（独占和共享）共用同一个字段。 |
| `Thread thread`   | 获取同步状态的线程                                           |

独占式同步状态的获取与释放：
		通过调用同步器的`acquire(int arg)`方法可以获取同步状态，该方法对终端不敏感，也就是说，由于线程获取同步状态失败后进入同步队列中，后续对线程进行终端操作时，线程不会从同步队列中移出，`acquire(int arg)`如下：

```java
    /**
     * Acquires in exclusive mode, ignoring interrupts.  Implemented
     * by invoking at least once {@link #tryAcquire},
     * returning on success.  Otherwise the thread is queued, possibly
     * repeatedly blocking and unblocking, invoking {@link
     * #tryAcquire} until success.  This method can be used
     * to implement method {@link Lock#lock}.
     *
     * @param arg the acquire argument.  This value is conveyed to
     *        {@link #tryAcquire} but is otherwise uninterpreted and
     *        can represent anything you like.
     */
    public final void acquire(int arg) {
        if (!tryAcquire(arg) &&
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
            selfInterrupt();
    }
```

​		上述代码的主要逻辑：首先调用自定义同步器实现的`tryAcquire(int arg)`方法，该方法保证线程安全的获取同步状态，如果同步状态获取失败，则构造同步节点（独占式`Node.EXCLUSIVE`，同一时刻只能有一个线程成功获取同步状态）并通过`addWaiter(Node node)`方法将该节点加入到同步队列的尾部，最后调用`acquireQueued(Node node, int arg)`方法，使得该节点以循环的方式获取同步状态，在每次循环中，获取失败后都会挂起当前线程。而该线程被唤醒是在成功获取同步状态的线程或被中断后主动唤醒它的后继节点来实现的。

​		构造与添加节点的方法代码如下：

```java
    /**
     * Creates and enqueues node for current thread and given mode.
     *
     * @param mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared
     * @return the new node
     */
    private Node addWaiter(Node mode) {
        Node node = new Node(Thread.currentThread(), mode);
        // Try the fast path of enq; backup to full enq on failure
        Node pred = tail;
        if (pred != null) {
            node.prev = pred;
            if (compareAndSetTail(pred, node)) {
                pred.next = node;
                return node;
            }
        }
        enq(node);
        return node;
    }
    
    /**
     * Inserts node into queue, initializing if necessary. See picture above.
     * @param node the node to insert
     * @return node's predecessor
     */
    private Node enq(final Node node) {
        for (;;) {
            Node t = tail;
            if (t == null) { // Must initialize
                if (compareAndSetHead(new Node()))
                    tail = head;
            } else {
                node.prev = t; // 步骤1
                if (compareAndSetTail(t, node)) {// 步骤2
                    t.next = node;// 步骤3
                    return t;
                }
            }
        }
    }
```

​		上述代码首先构造一个独占模式的节点，然后尝试CAS修改`tail`的引用。如果失败，则以自旋模式CAS更改`tail`的值，保证线程安全。

> 注意：这里的节点的后继引用的赋值并不是同步的，步骤1先行发生于步骤2，但步骤2并不先行发生与步骤3。这也解释了在AQS中，Node节点是双向链表，但是并没有出现用`node.next`来进行节点的遍历。参见`unparkSuccessor(Node node)`方法。

​		节点进入同步队列后，会自旋判断是否可以获取同步状态，并在获取失败，阻塞当前线程，并且判断当前线程是否已经被中断，最终返回中断状态。代码如下：

```java
    /**
     * Acquires in exclusive uninterruptible mode for thread already in
     * queue. Used by condition wait methods as well as acquire.
     *
     * @param node the node
     * @param arg the acquire argument
     * @return {@code true} if interrupted while waiting
     */
    final boolean acquireQueued(final Node node, int arg) {
        boolean failed = true;
        try {
            boolean interrupted = false;
            for (;;) {
                final Node p = node.predecessor();
                if (p == head && tryAcquire(arg)) {
                    setHead(node);
                    p.next = null; // help GC
                    failed = false;
                    return interrupted;
                }
                if (shouldParkAfterFailedAcquire(p, node) &&
                    parkAndCheckInterrupt())
                    interrupted = true;
            }
        } finally {
            if (failed)
                cancelAcquire(node);
        }
    }
```

​		只有前驱节点是头节点才能够尝试去获取同步状态，这样也就实现了FIFO原则。当获得同步状态后，就需要释放同步状态，使得后继节点能够继续获取同步状态。释放同步状态是通过`release(int arg)`方法实现：

```java
    /**
     * Releases in exclusive mode.  Implemented by unblocking one or
     * more threads if {@link #tryRelease} returns true.
     * This method can be used to implement method {@link Lock#unlock}.
     *
     * @param arg the release argument.  This value is conveyed to
     *        {@link #tryRelease} but is otherwise uninterpreted and
     *        can represent anything you like.
     * @return the value returned from {@link #tryRelease}
     */
    public final boolean release(int arg) {
        if (tryRelease(arg)) {
            Node h = head;
            if (h != null && h.waitStatus != 0)
                unparkSuccessor(h);
            return true;
        }
        return false;
    }
```

​		成功释放同步状态后，需要唤醒后继节点线程，`unparkSuccessor(Node node)`方法使用`LockSupport`来唤醒处于等待状态的线程。

共享式的获取与释放：

​		共享式与独占式的区别在于同一时刻是否有多个线程同时获取到同步状态。以文件的读写为例，如果一个程序在对文件进行读操作，那么这一时刻对于该文件的写操作均被阻塞，而读操作能够同时进行。写操作要求对资源的独占式访问，而读操作可以是共享式访问。
通过同步器的`acquireShared(int arg)`方法可以共享式地获取同步状态。代码如下：

```java
    /**
     * Acquires in shared mode, ignoring interrupts.  Implemented by
     * first invoking at least once {@link #tryAcquireShared},
     * returning on success.  Otherwise the thread is queued, possibly
     * repeatedly blocking and unblocking, invoking {@link
     * #tryAcquireShared} until success.
     *
     * @param arg the acquire argument.  This value is conveyed to
     *        {@link #tryAcquireShared} but is otherwise uninterpreted
     *        and can represent anything you like.
     */
    public final void acquireShared(int arg) {
        if (tryAcquireShared(arg) < 0)
            doAcquireShared(arg);
    }
    /**
     * Acquires in shared uninterruptible mode.
     * @param arg the acquire argument
     */
    private void doAcquireShared(int arg) {
        final Node node = addWaiter(Node.SHARED);
        boolean failed = true;
        try {
            boolean interrupted = false;
            for (;;) {
                final Node p = node.predecessor();
                if (p == head) {
                    int r = tryAcquireShared(arg);
                    if (r >= 0) {
                        setHeadAndPropagate(node, r);
                        p.next = null; // help GC
                        if (interrupted)
                            selfInterrupt();
                        failed = false;
                        return;
                    }
                }
                if (shouldParkAfterFailedAcquire(p, node) &&
                    parkAndCheckInterrupt())
                    interrupted = true;
            }
        } finally {
            if (failed)
                cancelAcquire(node);
        }
    }
```

​		在该方法中，同步器调用`tryAcquireShared(int arg)`方法尝试获取同步状态，`tryAcquireShared(int arg)`方法返回值为int类型，当返回值大于等于0时，表示获取成功。小于0则表示获取失败。代码逻辑与独占式获取相似，不同点在于对成功获取的判断条件不同。

​		共享式获取同步状态之后，也需要能够释放同步状态，通过调用`releaseShared(int arg)`方法释放同步状态，代码如下：

```java
    /**
     * Releases in shared mode.  Implemented by unblocking one or more
     * threads if {@link #tryReleaseShared} returns true.
     *
     * @param arg the release argument.  This value is conveyed to
     *        {@link #tryReleaseShared} but is otherwise uninterpreted
     *        and can represent anything you like.
     * @return the value returned from {@link #tryReleaseShared}
     */
    public final boolean releaseShared(int arg) {
        if (tryReleaseShared(arg)) {
            doReleaseShared();
            return true;
        }
        return false;
    }
    /**
     * Release action for shared mode -- signals successor and ensures
     * propagation. (Note: For exclusive mode, release just amounts
     * to calling unparkSuccessor of head if it needs signal.)
     */
    private void doReleaseShared() {
        /*
         * Ensure that a release propagates, even if there are other
         * in-progress acquires/releases.  This proceeds in the usual
         * way of trying to unparkSuccessor of head if it needs
         * signal. But if it does not, status is set to PROPAGATE to
         * ensure that upon release, propagation continues.
         * Additionally, we must loop in case a new node is added
         * while we are doing this. Also, unlike other uses of
         * unparkSuccessor, we need to know if CAS to reset status
         * fails, if so rechecking.
         */
        for (;;) {
            Node h = head;
            if (h != null && h != tail) {
                int ws = h.waitStatus;
                if (ws == Node.SIGNAL) {
                    if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))
                        continue;            // loop to recheck cases
                    unparkSuccessor(h);
                }
                else if (ws == 0 &&
                         !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))
                    continue;                // loop on failed CAS
            }
            if (h == head)                   // loop if head changed
                break;
        }
    }
```

​		因为是共享式的获取，所以同步状态的释放需要保证线程安全，一般通过循环CAS的方式来完成。

独占式超时获取同步状态：

​		超时获取同步状态是支持响应中断的获取的增强版，在循环中不断地判断当前时间是否已经超时，如果未超时，则通过`LockSupport.parkNanos`方法让当前线程在允许的时间内中断该线程。代码如下：

```java
    /**
     * Acquires in exclusive timed mode.
     *
     * @param arg the acquire argument
     * @param nanosTimeout max wait time
     * @return {@code true} if acquired
     */
    private boolean doAcquireNanos(int arg, long nanosTimeout)
            throws InterruptedException {
        if (nanosTimeout <= 0L)
            return false;
        final long deadline = System.nanoTime() + nanosTimeout;
        final Node node = addWaiter(Node.EXCLUSIVE);
        boolean failed = true;
        try {
            for (;;) {
                final Node p = node.predecessor();
                if (p == head && tryAcquire(arg)) {
                    setHead(node);
                    p.next = null; // help GC
                    failed = false;
                    return true;
                }
                nanosTimeout = deadline - System.nanoTime();
                if (nanosTimeout <= 0L)
                    return false;
                if (shouldParkAfterFailedAcquire(p, node) &&
                    nanosTimeout > spinForTimeoutThreshold)
                    LockSupport.parkNanos(this, nanosTimeout);
                if (Thread.interrupted())
                    throw new InterruptedException();
            }
        } finally {
            if (failed)
                cancelAcquire(node);
        }
    }
```

##### 重入锁

​		重入锁`ReentrantLock`，支持可重入的锁，它表示该锁能够支持一个线程对资源的重复加锁。除此之外，该锁还支持获取锁时的公平和非公平性选择。

​		锁本身理应具有互斥性，但是在更多场景中，要求对已经获得锁的线程也要能够获取锁。

​		锁获取的公平性问题，如果在绝对时间上，先对锁进行获取的请求一定先被满足，那么这个锁是公平的，反之，是不公平的。

1. 可重入锁的实现
   要实现可重入，需要解决两个问题：

   - 线程再次获取锁。锁需要能够识别获取锁的线程是否是当前的线程。
   - 锁的最终释放。线程重复获取锁n次，需要在第n次释放锁后，其他线程能够获取该锁。这就要求锁的获取要有一个计数，每次获取后自增。锁释放时，该计数自减，当计数为0时，表示锁已经成功释放。

   `ReentrantLock`通过自定义同步器来实现锁的获取与释放，以非公平性实现为例，获取同步状态的代码如下：

   ```java
           /**
            * Performs non-fair tryLock.  tryAcquire is implemented in
            * subclasses, but both need nonfair try for trylock method.
            */
           final boolean nonfairTryAcquire(int acquires) {
               final Thread current = Thread.currentThread();
               int c = getState();
               if (c == 0) {
                   if (compareAndSetState(0, acquires)) {
                       setExclusiveOwnerThread(current);
                       return true;
                   }
               }
               else if (current == getExclusiveOwnerThread()) {
                   int nextc = c + acquires;
                   if (nextc < 0) // overflow
                       throw new Error("Maximum lock count exceeded");
                   setState(nextc);
                   return true;
               }
               return false;
           }
   ```

   ​		该方法的逻辑是：如果当前同步状态为0，则尝试更新同步状态值，如果成功，则设置该线程为当前获得同步状态的线程，并返回。如果不是0，则判断当前线程是否获得锁，是，则让同步状态值自增。

   ​		成功获取锁的线程再次获取锁，只增加了同步状态值，这就要求在释放锁的是否减少该同步状态值：

   ```java
           protected final boolean tryRelease(int releases) {
               int c = getState() - releases;
               if (Thread.currentThread() != getExclusiveOwnerThread())
                   throw new IllegalMonitorStateException();
               boolean free = false;
               if (c == 0) {
                   free = true;
                   setExclusiveOwnerThread(null);
               }
               setState(c);
               return free;
           }
   ```

   ​		如果获得锁的线程是当前线程，则让同步状态减小，当同步状态为0时，设置获得同步状态的线程为null，返回true，表示释放成功。

2. 公平与非公平锁的实现
   实现公平锁，要让获取锁的请求都去排队，按照FIFO的顺序获取同步状态。前面我们介绍了非公平锁的获取，只要尝试更新同步状态成功，则获取锁成功。而公平锁不同：

   ```java
           /**
            * Fair version of tryAcquire.  Don't grant access unless
            * recursive call or no waiters or is first.
            */
           protected final boolean tryAcquire(int acquires) {
               final Thread current = Thread.currentThread();
               int c = getState();
               if (c == 0) {
                   if (!hasQueuedPredecessors() &&
                       compareAndSetState(0, acquires)) {
                       setExclusiveOwnerThread(current);
                       return true;
                   }
               }
               else if (current == getExclusiveOwnerThread()) {
                   int nextc = c + acquires;
                   if (nextc < 0)
                       throw new Error("Maximum lock count exceeded");
                   setState(nextc);
                   return true;
               }
               return false;
           }
       }
   ```

   ​		该方法与`nonfairTryAcquire(int acquires)`不同的位置只多了一个条件`hasQueuedPredecessors()`方法，该方法判断当前队列中是否有等待获取锁的线程，如果是，则获取失败。反之，才尝试获取。

##### 读写锁

​		一般我们提到的锁基本上都是排他锁，排他锁在同一时刻只允许一个线程进行访问，而读写锁在同一时刻可以允许多个读线程访问，但是在写线程访问时，所有的读线程和其他的写线程均被阻塞。读写锁维护了一对锁（逻辑上是一对，不会维护两个同步状态），一个读锁，一个写锁，读写分离，使得并发性相比一般的排他锁有了很大提升。

​		在缓存场景中，大部分时间提供读服务，而写操作占用的时间很少，但是写操作之后的更新需要对后续的读服务可见。同时也要保证在写操作前，没有正在进行读操作的线程，防止出现脏读。

​		在没有读写锁支持的时候，如果需要完成上述工作就要使用Java的等待通知机制，当写操作开始时，所有晚于写操作的读操作均会进入等待状态，只有写操作完成并进行通知后，所有等待的读操作才能继续执行。改用读写锁实现上述功能，只需要读操作时获取读锁，写操作时获取写锁即可。当写锁获取到时，后续的读写操作都会被阻塞，写锁释放后，后续操作继续执行。

​		一般形况下，在读多写少的场景下，读写锁相比于排他锁，能够提供比排他锁更好的并发性和吞吐量。读写锁也支持很多特性：

- 公平性。支持非公平（默认）和公平模式，在非公平模式下，能够提供更好的吞吐量
- 可重入。支持可重入。
- 锁降级。在获取写锁后可以获取读锁。

###### 读写锁的实现

​		包括：读写状态的设计、写锁的获取与释放、读锁的获取与释放以及锁降级。

1. 读写状态的设计
    		读写锁同样依赖自定义同步器来实现同步功能，而读写状态就是同步器的状态。在之前的`ReetrantLock`实现中，同步状态用来表示锁被一个线程重复获取的次数，而读写锁需要维护读、写两个状态。如何设计同步状态就显得非常关键。
        		如果真就维护两个同步器分别管理读和写的状态，而读状态和写状态都需要通信的，这无疑又进入另一个需要同步的逻辑。所以只能使用一个同步器来维护。自然想到的就是按位分割的方式来维护同步状态值。
        		读状态用高16位表示，写状态用低16位表示。而同步状态的解析与判断是通过位运算来完成的。

2. 写锁的获取与释放

    ​		写锁是一个可重入的排他锁。如果当前线程已经获取了写锁，则增加写状态。如果当前线程在获取写锁时，读锁已经被获取或者该线程不是已经获取写锁的线程，则当前线程进入等待状态，获取写锁的代码如下：

    ```java
            protected final boolean tryAcquire(int acquires) {
                /*
                 * Walkthrough:
                 * 1. If read count nonzero or write count nonzero
                 *    and owner is a different thread, fail.
                 * 2. If count would saturate, fail. (This can only
                 *    happen if count is already nonzero.)
                 * 3. Otherwise, this thread is eligible for lock if
                 *    it is either a reentrant acquire or
                 *    queue policy allows it. If so, update state
                 *    and set owner.
                 */
                Thread current = Thread.currentThread();
                int c = getState();
                int w = exclusiveCount(c);
                if (c != 0) {
                    // (Note: if c != 0 and w == 0 then shared count != 0)
                    if (w == 0 || current != getExclusiveOwnerThread())
                        return false;
                    if (w + exclusiveCount(acquires) > MAX_COUNT)
                        throw new Error("Maximum lock count exceeded");
                    // Reentrant acquire
                    setState(c + acquires);
                    return true;
                }
                if (writerShouldBlock() ||
                    !compareAndSetState(c, c + acquires))
                    return false;
                setExclusiveOwnerThread(current);
                return true;
            }
    ```

    ​		代码中判断了读锁的数量是否大于0，如果存在读锁，则不能获取写锁。用来保证写操作能对读操作可见。

    ​		写锁的释放与`ReentrantLock`的释放过程基本类似。

    ```java
            /*
             * Note that tryRelease and tryAcquire can be called by
             * Conditions. So it is possible that their arguments contain
             * both read and write holds that are all released during a
             * condition wait and re-established in tryAcquire.
             */
    
            protected final boolean tryRelease(int releases) {
                if (!isHeldExclusively())
                    throw new IllegalMonitorStateException();
                int nextc = getState() - releases;
                boolean free = exclusiveCount(nextc) == 0;
                if (free)
                    setExclusiveOwnerThread(null);
                setState(nextc);
                return free;
            }
    ```

3. 读锁的获取与释放

    ​		读锁是一个可重入的共享锁，它能够被多个线程同时获取，在写状态等于0时（表示没有被其他写线程获取锁），读锁获取总是成功的，只需要安全的更新读状态（增加1）。

    ```java
            protected final int tryAcquireShared(int unused) {
                /*
                 * Walkthrough:
                 * 1. If write lock held by another thread, fail.
                 * 2. Otherwise, this thread is eligible for
                 *    lock wrt state, so ask if it should block
                 *    because of queue policy. If not, try
                 *    to grant by CASing state and updating count.
                 *    Note that step does not check for reentrant
                 *    acquires, which is postponed to full version
                 *    to avoid having to check hold count in
                 *    the more typical non-reentrant case.
                 * 3. If step 2 fails either because thread
                 *    apparently not eligible or CAS fails or count
                 *    saturated, chain to version with full retry loop.
                 */
                Thread current = Thread.currentThread();
                int c = getState();
                if (exclusiveCount(c) != 0 &&
                    getExclusiveOwnerThread() != current)
                    return -1;
                int r = sharedCount(c);
                if (!readerShouldBlock() &&
                    r < MAX_COUNT &&
                    compareAndSetState(c, c + SHARED_UNIT)) {
                    if (r == 0) {
                        firstReader = current;
                        firstReaderHoldCount = 1;
                    } else if (firstReader == current) {
                        firstReaderHoldCount++;
                    } else {
                        HoldCounter rh = cachedHoldCounter;
                        if (rh == null || rh.tid != getThreadId(current))
                            cachedHoldCounter = rh = readHolds.get();
                        else if (rh.count == 0)
                            readHolds.set(rh);
                        rh.count++;
                    }
                    return 1;
                }
                return fullTryAcquireShared(current);
            }
    ```

    ​		如果其他线程（不包括该线程）获取了写锁，则获取读锁时失败，进入等待状态。如果当前线程获得了写锁或者写锁没有被获取，则当前线程增加读状态，成功获取读锁。

    ​		读锁的释放均会减少读状态。代码如下：

    ```java
            protected final boolean tryReleaseShared(int unused) {
                Thread current = Thread.currentThread();
                if (firstReader == current) {
                    // assert firstReaderHoldCount > 0;
                    if (firstReaderHoldCount == 1)
                        firstReader = null;
                    else
                        firstReaderHoldCount--;
                } else {
                    HoldCounter rh = cachedHoldCounter;
                    if (rh == null || rh.tid != getThreadId(current))
                        rh = readHolds.get();
                    int count = rh.count;
                    if (count <= 1) {
                        readHolds.remove();
                        if (count <= 0)
                            throw unmatchedUnlockException();
                    }
                    --rh.count;
                }
                for (;;) {
                    int c = getState();
                    int nextc = c - SHARED_UNIT;
                    if (compareAndSetState(c, nextc))
                        // Releasing the read lock has no effect on readers,
                        // but it may allow waiting writers to proceed if
                        // both read and write locks are now free.
                        return nextc == 0;
                }
            }
    ```

4. 锁降级

    ​		如果一个线程获得了写锁，那么它在不释放该锁的情况下获得读取锁，就使得该锁降级为读锁。它阻止了其他写线程修改被保护的资源。

##### LockSupport工具

​		阻塞线程的方式可以使用`Ojbect`的 `wait()`、`notify()`来实现，然而该方式依赖监视器对象。`LockSupport`提供创建锁和其他同步类的基本线程阻塞原语。

| 方法名称                        | 描述                                                         |
| ------------------------------- | ------------------------------------------------------------ |
| `void park()`                   | 阻塞当前线程，如果调用`unpark(Thread thred)`方法或者当前线程被中断或者虚假唤醒，当前线程会从`park()`方法中返回 |
| `void parkNanos(long nanos)`    | 增加超时参数                                                 |
| `void parkUntil(long deadline)` | 阻塞当前线程，直到deadline时间（从1970年到deadline的毫秒数） |
| `void unpark(Thread thread)`    | 唤醒处于阻塞状态的线程thread                                 |

##### Condition接口

​		任何一个Java对象，都拥有一组监视器方法（`wait()`、`notify()`等），这些方法依赖`synchronized`关键字来实现等待/通知模式。`Condition`也提供了类似的类似方法，与`Lock`配合可以实现等待/通知模式，但两者存在差别的。

| 对比项                                       | `Object Monitor Methods` | `Condition`                                                  |
| -------------------------------------------- | ------------------------ | ------------------------------------------------------------ |
| 前置条件                                     | 获取对象的锁             | 调用`Lock.lock()`获得锁且调用`Lock.newCondition()`获取`Condition`对象 |
| 等待队列个数                                 | 一个                     | 多个                                                         |
| 当前线程释放锁并进入等待状态                 | 支持                     | 支持                                                         |
| 当前线程释放锁并进入等待状态，但不响应中断   | 不支持                   | 支持                                                         |
| 当前线程释放锁并进入超时等待状态             | 支持                     | 支持                                                         |
| 当前线程释放锁并进入等待状态到将来的某个时间 | 不支持                   | 支持                                                         |
| 唤醒等待队列中的一个线程                     | 支持                     | 支持                                                         |
| 唤醒等待队列中的全部线程                     | 支持                     | 支持                                                         |

​		`COndition`定义的方法有：

| 方法名称                                                     | 描述                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| `viod await() throws InterruptedException`                   | 使当前线程等待，直到发出信号或当前线程被中断，直到发生以下情况中的一个条件：<br>1. 其他线程调用该`Condition`的`signal()`方法，而当前线程恰好被选中唤醒<br>2. 其他线程调用了该`Condition`的`signalAll()`方法<br>3. 其他线程中断了该线程，并支持中断线程挂起<br>4. 发生了虚假唤醒 |
| `void awaitUnniterruptibly()`                                | 使当前线程等待，直到发出信号或当前线程被中断，直到发生以下情况中的一个条件：<br/>1. 其他线程调用该`Condition`的`signal()`方法，而当前线程恰好被选中唤醒<br/>2. 其他线程调用了该`Condition`的`signalAll()`方法<br/>3. 发生了虚假唤醒<br/>如果当前线程进入此方法时设置了中断状态，或者在等待时被中断，它将继续等待直到发出信号。 当它最终从该方法返回时，其中断状态仍将被设置。 |
| `long awaitNanos(long nanosTimeout) throws InterruptedException` | 使当前线程等待，直到发出信号或当前线程被中断或超时。nanosTimeout值的估计值减去从此方法返回之前等待的时间。 可以将正值用作对该方法的后续调用的参数，以完成等待所需的时间。 小于或等于零的值表示没有时间剩余。 |
| `boolean awaitUntil(Date deadline) throws InterruptedException` | 使当前线程等待，直到发出信号或当前线程被中断或超时。如果截止日期已过，则返回false ，否则返回true |
| `void signal()`                                              | 唤醒一个等待在`Condition`上的线程，该线程从等待方法返回前必须获得与`Condition`相关联的锁 |
| `void signalAll()`                                           | 唤醒所有等待在`Condition`的线程，能够从等待方法返回的线程必须获得与`Conditon`相关联的锁 |



#### 五：Java并发容器和框架

#### 六：Java原子操作类

#### 七：Java并发工具类

#### 八：Java线程池

#### 九：Executor框架

